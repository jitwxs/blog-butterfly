<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Protobuf 学习手册——语法篇 | Jitwxs</title><meta name="keywords" content="Protobuf"><meta name="author" content="Jitwxs"><meta name="copyright" content="Jitwxs"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、Override Protobuf[1] 是一种语言中立、平台无关、可扩展的序列化数据的格式，可用于通信协议，数据存储等。 ProtoBuf 在序列化数据方面，它是灵活的、高效的。相比于 XML 来说，ProtoBuf 更加小巧、更加快速、更加简单。一旦定义了要处理的数据的数据结构之后，就可以利用 ProtoBuf 的代码生成工具生成相关的代码。甚至可以在无需重新部署程序的情况下更新数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="Protobuf 学习手册——语法篇">
<meta property="og:url" content="https://jitwxs.cn/60aca815.html">
<meta property="og:site_name" content="Jitwxs">
<meta property="og:description" content="一、Override Protobuf[1] 是一种语言中立、平台无关、可扩展的序列化数据的格式，可用于通信协议，数据存储等。 ProtoBuf 在序列化数据方面，它是灵活的、高效的。相比于 XML 来说，ProtoBuf 更加小巧、更加快速、更加简单。一旦定义了要处理的数据的数据结构之后，就可以利用 ProtoBuf 的代码生成工具生成相关的代码。甚至可以在无需重新部署程序的情况下更新数据结构">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/top/cover16.jpg">
<meta property="article:published_time" content="2019-12-24T14:58:39.000Z">
<meta property="article:modified_time" content="2020-12-26T13:52:06.941Z">
<meta property="article:author" content="Jitwxs">
<meta property="article:tag" content="Protobuf">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/top/cover16.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/configuration/favicon.ico"><link rel="canonical" href="https://jitwxs.cn/60aca815"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?053091e29f160d71ed2f65a774cfeac1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-40VH67TNSM"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-40VH67TNSM');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"POGNXMLA2T","apiKey":"2013ebed0f76818838d693c9c40cb1fd","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Jitwxs","link":"链接: ","source":"来源: Jitwxs","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-12-26 21:52:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Jitwxs" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/configuration/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">224</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">132</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">39</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fas fa-ellipsis-v"></i><span> 更多</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fa fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/favorites/"><i class="fa-fw fas fa-meteor"></i><span> 收藏夹</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://tools.jitwxs.cn"><i class="fa-fw fas fa-tools"></i><span> 工具箱</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-cogs"></i><span> 管理</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/changes/"><i class="fa-fw fas fa-location-arrow"></i><span> 更新日志</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://analytics.google.com/"><i class="fa-fw fab fa-google"></i><span> 谷歌统计</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://tongji.baidu.com/"><i class="fa-fw fas fa-globe-asia"></i><span> 百度统计</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/top/cover16.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jitwxs</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fas fa-ellipsis-v"></i><span> 更多</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fa fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/favorites/"><i class="fa-fw fas fa-meteor"></i><span> 收藏夹</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://tools.jitwxs.cn"><i class="fa-fw fas fa-tools"></i><span> 工具箱</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-cogs"></i><span> 管理</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/changes/"><i class="fa-fw fas fa-location-arrow"></i><span> 更新日志</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://analytics.google.com/"><i class="fa-fw fab fa-google"></i><span> 谷歌统计</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://tongji.baidu.com/"><i class="fa-fw fas fa-globe-asia"></i><span> 百度统计</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Protobuf 学习手册——语法篇<a class="post-edit-link" href="https://github.com/jitwxs/blog-source/tree/master/source/_posts/Protobuf-学习手册——语法篇.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="article-meta"><i class="fas fa-user post-meta-icon"></i><span class="article-meta-label">Jitwxs</span><span class="post-meta-separator">|</span></span><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-12-24T14:58:39.000Z" title="发表于 2019-12-24 22:58:39">2019-12-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-12-26T13:52:06.941Z" title="更新于 2020-12-26 21:52:06">2020-12-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/Protobuf/">Protobuf</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Protobuf 学习手册——语法篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/60aca815.html#post-comment"><span class="gitalk-comment-count"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一-override"><a class="markdownIt-Anchor" href="#一-override"></a> 一、Override</h2>
<p><code>Protobuf</code><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 是一种语言中立、平台无关、可扩展的<strong>序列化数据的格式</strong>，可用于通信协议，数据存储等。</p>
<p>ProtoBuf 在序列化数据方面，它是灵活的、高效的。相比于 XML 来说，ProtoBuf 更加小巧、更加快速、更加简单。一旦定义了要处理的数据的数据结构之后，就可以利用 ProtoBuf 的代码生成工具生成相关的代码。甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 ProtoBuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。</p>
<p><strong>ProtoBuf 很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式</strong>。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/201912/20191224230003235.png" alt="protocol buffers logo" /></p>
<h3 id="11-为什么要发明-protobuf"><a class="markdownIt-Anchor" href="#11-为什么要发明-protobuf"></a> 1.1 为什么要发明 Protobuf</h3>
<p>大家可能会觉得 Google 发明 ProtoBuf 是为了解决序列化速度的，其实真实的原因并不是这样的。</p>
<p>ProtoBuf 最先开始是 Google 用来解决索引服务器 request/response 协议的。没有 ProtoBuf 之前，google 已经存在了一种 request/response 格式，用于手动处理 request/response 的编组和反编组。它也能支持多版本协议，不过代码比较丑陋：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (version == <span class="number">3</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (version &gt; <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (version == <span class="number">5</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果非常明确的格式化协议，就会使新协议变得非常复杂。因为开发人员必须确保请求发起者与处理请求的实际服务器之间的所有服务器都能理解新协议，然后才能切换开关以开始使用新协议。这也就是每个服务器开发人员都遇到过的低版本兼容、新旧协议兼容相关的问题。</p>
<p>为了解决这些问题，ProtoBuf 诞生了，它具有以下两个特点：</p>
<ul>
<li>可以很容易地引入新的字段，并且不需要检查数据的中间服务器可以简单地解析并传递数据，而无需了解所有字段。</li>
<li>数据格式更加具有自我描述性，可以用各种语言来处理(C++, Java 等各种语言)</li>
</ul>
<p>最初版本的 ProtoBuf 仍需要自己手写解析的代码，不过随着系统慢慢发展演进，ProtoBuf 目前具有了更多的特性：</p>
<ul>
<li>自动生成序列化和反序列化代码避免了手动解析的需要（官方提供自动生成代码工具，各个语言平台的基本都有）。</li>
<li>除了用于 RPC 请求之外，人们开始将 ProtoBuf 用作持久存储数据的便捷自描述格式。</li>
<li>服务器的 RPC 接口可以先声明为协议的一部分，然后用 protocol compiler 生成基类，用户可以使用服务器接口的实际实现来覆盖它们。</li>
</ul>
<p>ProtoBuf 现在是 Google 用于数据的通用语言，它们既用于 RPC 系统，也用于在各种存储系统中持久存储数据。</p>
<p><strong>总结：</strong> ProtoBuf 诞生之初是为了解决服务器端新旧协议(高低版本)兼容性问题，只不过后期慢慢发展成用于数据传输。</p>
<h3 id="12-命名由来"><a class="markdownIt-Anchor" href="#12-命名由来"></a> 1.2 命名由来</h3>
<blockquote>
<p>The name originates from the early days of the format, before we had the protocol buffer compiler to generate classes for us. At the time, there was a class called ProtocolBuffer which actually acted as a buffer for an individual method. Users would add tag/value pairs to this buffer individually by calling methods like AddValue(tag, value). The raw bytes were stored in a buffer which could then be written out once the message had been constructed.</p>
<p>Since that time, the “buffers” part of the name has lost its meaning, but it is still the name we use. Today, people usually use the term “protocol message” to refer to a message in an abstract sense, “protocol buffer” to refer to a serialized copy of a message, and “protocol message object” to refer to an in-memory object representing the parsed message.</p>
</blockquote>
<p>Protocol buffer 这个名字起源于 format 早期，在我们有 protocol buffer 编译器为我们生成类之前。当时，有一个名为 ProtocolBuffer 的类，它实际上充当了单个方法的缓冲区。用户可以通过调用像 AddValue(tag, value) 这样的方法分别将标签/值对添加到此缓冲区。原始字节存储在一个缓冲区中，一旦构建消息就可以将其写出。</p>
<p>从那时起，名为“缓冲”的部分已经失去了意义，但它仍然是我们使用的名称。今天，人们通常使用术语“protocol message”来指代抽象意义上的消息，“protocol buffer”指的是消息的序列化副本，而“protocol message object”指的是代表内存中对象解析的消息。</p>
<h3 id="13-proto2-or-proto3"><a class="markdownIt-Anchor" href="#13-proto2-or-proto3"></a> 1.3 Proto2 or Proto3</h3>
<p>Protobuf 存在 Proto2 和 Proto3 两个版本，和 Python 一样，Proto3 是今后的主要版本，Proto2 除了用于历史遗留项目外，不被推荐使用。因此对于初学者来说，选择 Proto3 进行学习和使用是毋庸置疑的。截止到本文编写时最新的 Relaese 版本是 <strong>3.11.0</strong>。</p>
<p>你可能会疑惑为什么没有 Proto1，这是因为 Google 起初开源 Protobuf 时，在 Google 内部实际上已经是第二个版本了。为了保持版本的统一，索性开源版本就从 v2.0.0 开始了。</p>
<p>Proto3 不完全兼容 Proto2，下面列出我发现的不同之处，后续我会持续在这里补充。</p>
<ul>
<li>首行必须是 <code>syntax = &quot;proto3&quot;;</code> 用于标识使用 Protobuf3 解析。</li>
<li>移除了 <code>required</code>  关键字，因为它破坏了 Protobuf 向前/后兼容的特点。</li>
<li>移除了 <code>optional</code> 关键字，如果字段不赋值，那么就是使用字段类型的默认值。Protobuf3 在字段被设置为默认值的时候，不会序列化该字段。这样可以节省空间，提高效率。</li>
<li>移除了 <code>default</code> 关键字，不再允许手动指定某个字段的默认值，只能使用字段类型的默认值。这可能会导致 Protobuf2 和 Protubuf3 的不兼容，例如 Protobuf2 中手动指定了字段的默认值，在 Protobuf3 中就会忽略该字段。</li>
<li>枚举类型第一个字段编号必须为 <code>0</code>，它是该枚举的默认值。</li>
</ul>
<h3 id="14-对比-xml"><a class="markdownIt-Anchor" href="#14-对比-xml"></a> 1.4 对比 XML</h3>
<p>Protobuf 在序列化方面，与 XML 相比，有诸多优点：</p>
<ul>
<li>更加简单</li>
<li>数据体积小 3 - 10 倍</li>
<li>更快的反序列化速度，提高 20 - 100 倍</li>
<li>可以自动化生成更易于编码方式使用的数据访问类</li>
</ul>
<p>举个例子，如果要编码一个用户的名字和 email 信息，用 XML 的方式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>John Doe<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">email</span>&gt;</span>jdoe@example.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>相同需求，如果换成 Protobuf 来实现，定义文件如下：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Textual representation of a protocol buffer. This is not the binary format used on the wire.</span><br><span class="line">person &#123;</span><br><span class="line">  name: <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">  email: <span class="string">&quot;jdoe@example.com&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Protobuf 通过编码以后，以二进制的方式进行数据传输，最多只需要 28 bytes 空间和 100-200 ns 的反序列化时间。但是 XML 则至少需要 69 bytes 空间（经过压缩以后，去掉所有空格）和 5000-10000 的反序列化时间。</p>
<p>上面说的是性能方面的优势。接下来说说编码方面的优势。</p>
<p>Protobuf 自带代码生成工具，可以生成友好的数据访问存储接口。从而开发人员使用它来编码更加方便。例如上面的例子，如果用 C++ 的方式去读取用户的名字和 email，直接调用对应的 get 方法即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; person.<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;E-mail: &quot;</span> &lt;&lt; person.<span class="built_in">email</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>而 XML 读取数据会麻烦一些：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Name: &quot;</span></span><br><span class="line">     &lt;&lt; person.<span class="built_in">getElementsByTagName</span>(<span class="string">&quot;name&quot;</span>)-&gt;<span class="built_in">item</span>(<span class="number">0</span>)-&gt;<span class="built_in">innerText</span>()</span><br><span class="line">     &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;E-mail: &quot;</span></span><br><span class="line">     &lt;&lt; person.<span class="built_in">getElementsByTagName</span>(<span class="string">&quot;email&quot;</span>)-&gt;<span class="built_in">item</span>(<span class="number">0</span>)-&gt;<span class="built_in">innerText</span>()</span><br><span class="line">     &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>Protobuf 语义更清晰，无需类似 XML 解析器的东西（因为 Protobuf 编译器会将 .proto 文件编译生成对应的数据访问类以对 Protobuf 数据进行序列化、反序列化操作）。</p>
<p>使用 Protobuf 无需学习复杂的文档对象模型，Protobuf 的编程模式比较友好，简单易学，同时它拥有良好的文档和示例，对于喜欢简单事物的人们而言，Protobuf 比其他的技术更加有吸引力。</p>
<p>Protobuf 最后一个非常棒的特性是，即“向后”兼容性好，人们不必破坏已部署的、依靠“老”数据格式的程序就可以对数据结构进行升级。这样您的程序就可以不必担心因为消息结构的改变而造成的大规模的代码重构或者迁移的问题。因为添加新的消息中的 field 并不会引起已经发布的程序的任何改变(因为存储方式本来就是无序的，k-v 形式)。</p>
<p>当然 Protobuf 也并不是完美的，在使用上存在一些局限性。</p>
<p>由于文本并不适合用来描述数据结构，所以 Protobuf 也不适合用来对基于文本的标记文档（如 HTML）建模。另外，由于 XML 具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上 Protobuf 不行，它以二进制的方式存储，除非你有 <code>.proto</code> 定义，否则你没法直接读出 Protobuf 的任何内容。</p>
<h3 id="15-学习指南"><a class="markdownIt-Anchor" href="#15-学习指南"></a> 1.5 学习指南</h3>
<ul>
<li>
<p>Protobuf 官方文档：<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/overview">https://developers.google.com/protocol-buffers/docs/overview</a></p>
</li>
<li>
<p>Protobuf For Java 指南：<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/javatutorial">https://developers.google.com/protocol-buffers/docs/javatutorial</a></p>
</li>
<li>
<p>Protobuf GitHub：<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf">https://github.com/protocolbuffers/protobuf</a></p>
</li>
</ul>
<h2 id="二-message-定义"><a class="markdownIt-Anchor" href="#二-message-定义"></a> 二、Message 定义</h2>
<p>在 Protobuf 中，所有结构化的数据都被称为 <code>message</code>。假设你想要查询某个接口，这个接口需要传递这些参数关键字和分页参数（当前页和每页记录数），那么我们就可以把这些参数都定义成一个对象，用 Protobuf 的话说就是定义一个 message。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>syntax = &quot;proto3&quot;;</code> 指定了整个 .proto 文件使用 Protobuf3 解析，否则默认会使用 Protobuf2 解析，必须将其放置在文件的第一行。</li>
<li>SearchRequest 这个 message 指定了三个数据字段，每个数据字段定义由 <strong>Field Types 数据类型 + Field Names 字段名 = Field Numbers 编号</strong>组成。</li>
</ul>
<h3 id="21-字段类型"><a class="markdownIt-Anchor" href="#21-字段类型"></a> 2.1 字段类型</h3>
<h4 id="211-基础类型"><a class="markdownIt-Anchor" href="#211-基础类型"></a> 2.1.1  基础类型</h4>
<p>Protobuf 支持 Java、C++、Python、Go、Ruby、C#、PHP 等主流编程语言。限于博主是 Java 开发，因此只列出 Protobuf 数据类型和 Java 语言的类型的对应关系，其他语言见官方<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/proto3#scalar">完整表格</a>。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Protobuf 类型</th>
<th style="text-align:left">备注</th>
<th style="text-align:left">Java 类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left"></td>
<td style="text-align:left">double</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left"></td>
<td style="text-align:left">float</td>
</tr>
<tr>
<td style="text-align:left">int32</td>
<td style="text-align:left">使用可变长度编码。对负数编码效率低下，如果您的字段可能有负值，则使用sint 32代替。</td>
<td style="text-align:left">int</td>
</tr>
<tr>
<td style="text-align:left">int64</td>
<td style="text-align:left">使用可变长度编码。对负数编码效率低下，如果您的字段可能有负值，则使用sint 64代替。</td>
<td style="text-align:left">long</td>
</tr>
<tr>
<td style="text-align:left">uint32</td>
<td style="text-align:left">使用可变长度编码。</td>
<td style="text-align:left">int<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></td>
</tr>
<tr>
<td style="text-align:left">uint64</td>
<td style="text-align:left">使用可变长度编码。</td>
<td style="text-align:left">long<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup></td>
</tr>
<tr>
<td style="text-align:left">sint32</td>
<td style="text-align:left">使用可变长度编码。有符号的 int 型，比 int32 更适合处理负数。</td>
<td style="text-align:left">int</td>
</tr>
<tr>
<td style="text-align:left">sint64</td>
<td style="text-align:left">使用可变长度编码。有符号的 int 型，比 int36 更适合处理负数。</td>
<td style="text-align:left">long</td>
</tr>
<tr>
<td style="text-align:left">fixed32</td>
<td style="text-align:left">总是四个字节，如果值通常大于228，则比 uint 32 更有效。</td>
<td style="text-align:left">int<sup class="footnote-ref"><a href="#fn2" id="fnref2:2">[2:2]</a></sup></td>
</tr>
<tr>
<td style="text-align:left">fixed64</td>
<td style="text-align:left">总是八个字节，如果值通常大于256，则比 uint 64 更有效。</td>
<td style="text-align:left">long<sup class="footnote-ref"><a href="#fn2" id="fnref2:3">[2:3]</a></sup></td>
</tr>
<tr>
<td style="text-align:left">sfixed32</td>
<td style="text-align:left">总是四个字节</td>
<td style="text-align:left">int</td>
</tr>
<tr>
<td style="text-align:left">sfixed64</td>
<td style="text-align:left">总是八个字节</td>
<td style="text-align:left">long</td>
</tr>
<tr>
<td style="text-align:left">bool</td>
<td style="text-align:left"></td>
<td style="text-align:left">boolean</td>
</tr>
<tr>
<td style="text-align:left">string</td>
<td style="text-align:left">字符串必须始终包含 UTF-8 编码或 7 位 ASCII 文本，不长于 232</td>
<td style="text-align:left">String</td>
</tr>
<tr>
<td style="text-align:left">bytes</td>
<td style="text-align:left">可以包含不长于232的任意任意序列的字节</td>
<td style="text-align:left">ByteString</td>
</tr>
</tbody>
</table>
<p>除了支持以上这些基础数据类型外，Protobuf 还支持枚举和 message 类型。</p>
<h4 id="212-枚举类型"><a class="markdownIt-Anchor" href="#212-枚举类型"></a> 2.1.2 枚举类型</h4>
<p>Protobuf 支持枚举类型，还是以 SearchRequest 例子为例，假设想要加一个参数，用于指定查询的数据来源，例如可以从本地数据查询，也可以从历史数据查询。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">    SearchTypeEnum typeEnum = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SearchTypeEnum</span> </span>&#123;</span><br><span class="line">    LOCAL = <span class="number">0</span>;</span><br><span class="line">    HISTORY = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的，在 Proto3 中，<strong>枚举类型第一个元素的编号必须是 0，编号为 0 的枚举元素也这个枚举类的默认值</strong>。这样做是因为：</p>
<ul>
<li>强制枚举类包含一个编号为 0 的元素，这样枚举类型的默认值就可以定义为 0 了。</li>
<li>在 Proto2 中，第一个元素被认为是枚举类的默认值（除非显式指定），Proto3 这样做是为了兼容 Proto3。</li>
</ul>
<p>你可以通过将相同的编号分配给不同的枚举常量来定义别名，这样做需要设置  <code>allow_alias</code>  为 true，否则编译会因为重复编号而报错。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumAllowingAlias</span> </span>&#123;</span><br><span class="line">  <span class="keyword">option</span> allow_alias = <span class="literal">true</span>;</span><br><span class="line">  UNKNOWN = <span class="number">0</span>;</span><br><span class="line">  STARTED = <span class="number">1</span>;</span><br><span class="line">  RUNNING = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumNotAllowingAlias</span> </span>&#123;</span><br><span class="line">  UNKNOWN = <span class="number">0</span>;</span><br><span class="line">  STARTED = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类型序号必须在 32 位整数范围内。 由于枚举值在传输时使用 <code>varint</code> 编码，负值效率不高，因此不建议使用负值作为序号。</p>
<p>在反序列化中，无法识别的枚举值将保留在 message 中， 因为消息反序列化时如何表示是依赖于语言的 。 在支持开放枚举类型且值超过指定符号范围的语言中，例如 C++ 和 Go，未知的枚举值只是存储为其基础整数表示。而在诸如 Java 之类的封闭枚举类型的语言中，枚举中的一个 case 会被用于表示未识别的值，使用特殊的访问器可以访问到底层数值。</p>
<p>在其他情况下，如果消息被序列化，则无法识别的值仍将与消息一起序列化。</p>
<h4 id="213-message-类型"><a class="markdownIt-Anchor" href="#213-message-类型"></a> 2.1.3 Message 类型</h4>
<p>你可以使用其他 Message 类型作为字段【注：这有点类似于 Java 一个对象里面又有个对象字段】。如果想要在每个 SearchResponse 中包含 Result，可以像下面的例子一样将 Result 定义在同一个 .proto 文件中。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> Result results = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> url = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> title = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者定义在其他 .proto 文件并使用 import 导入进来，关于 Import 的更多内容见 <a href="#2-8-Import">2.8 节</a>。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;myproject/other_protos.proto&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="22-字段编号"><a class="markdownIt-Anchor" href="#22-字段编号"></a> 2.2 字段编号</h3>
<p>每个消息定义中的每个字段都有<strong>唯一的编号</strong>。这些字段编号用于标识消息二进制格式中的字段，并且在使定义后不应更改。</p>
<p>需要注意的是，范围 1 ~ 15 中的字段编号需要<strong>一个字节</strong>进行编码，包括字段编号和字段类型。范围 16 ~ 2047 中的字段编号需要<strong>两个字节</strong>进行编码。所以应该将非常频繁出现的元素放置在序号 1 到 15 上，别忘了为将来可能添加的频繁出现的元素预留出几个编号。</p>
<p>可以指定的最小字段编号为 1，最大字段编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>29</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{29}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">9</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 或 536,870,911。也不能使用数字 19000 到 19999（<code>FieldDescriptor :: kFirstReservedNumber</code> 到 <code>FieldDescriptor :: kLastReservedNumber</code>，Protobuf 保留区间）。如果在 Protobuf 中使用这些保留数字中的任何一个，编译会报错。同样不能使用任何以前 Protobufs 保留的一些字段号码。保留字段见 <a href="#2-6-%E4%BF%9D%E7%95%99%E5%AD%97%E6%AE%B5">2.6 节</a>。</p>
<h3 id="23-字段规则"><a class="markdownIt-Anchor" href="#23-字段规则"></a> 2.3 字段规则</h3>
<ul>
<li><code>singular</code>:  格式正确的 message 可以包含 0 个或 1 个此字段，这是 Protobuf3 语法的默认字段规则。</li>
<li><code>repeated</code>:  格式正确的 message 中，此字段可以重复任意次（包括 0 次）， 重复值的顺序将保留。</li>
</ul>
<p>在 Protobuf3 中， <code>repeated</code> 标识的字段如果是基础数据类型，那么默认会使用  <code>packed</code>  编码方式，详细见<a href="/d4225e9b.html">《Protobuf 学习手册——编码篇》</a>。</p>
<h3 id="24-添加多个-message"><a class="markdownIt-Anchor" href="#24-添加多个-message"></a> 2.4 添加多个 Message</h3>
<p>你可以在一个 .proto 文件中定义多个 message【注：就好似一个 Java 文件中可以定义多个 class 一样】。例如想要定义一个和 <code>SearchRequest</code> 相对应的响应 message，可以添加它到同一个 .proto 文件中：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="25-注释"><a class="markdownIt-Anchor" href="#25-注释"></a> 2.5 注释</h3>
<p>Protobuf 注释遵循 C / C++ 规范，你可以使用 <code>//</code> 或者 <code>/* ... */</code> 符号。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SearchRequest represents a search query, with pagination options to</span></span><br><span class="line"><span class="comment"> * indicate which results to include in the response. */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;  <span class="comment">// Which page number do we want?</span></span><br><span class="line">  <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;  <span class="comment">// Number of results to return per page.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-保留字段"><a class="markdownIt-Anchor" href="#26-保留字段"></a> 2.6 保留字段</h3>
<p>如果您通过完全删除某个字段或将其注释掉来更新枚举，那么未来的用户在对该类型进修改时可以重新使用该字段编号。如果加载到了旧版本的 <code>.proto</code> 文件，就会导致系统出现严重问题，例如数据混乱、隐私错误等等。</p>
<p>确保这种情况不会发生的一种方法是指定删除字段的字段编号或名称（这也可能会导致 JSON 序列化问题）为 <code>reserved</code>。如果试图使用被 reserved 的字段编号或名称，Protobuf 编译器将会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">  reserved 2, 15, 9 to 11;</span><br><span class="line">  reserved &quot;foo&quot;, &quot;bar&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意，不能在同一个 <code>reserved</code> 语句中混合字段名称和字段编号</strong>，如有需要需要请像上面这个例子这样写。</p>
<h3 id="27-默认值"><a class="markdownIt-Anchor" href="#27-默认值"></a> 2.7 默认值</h3>
<p>解析 message 时，如果编码的 message 不包含特定的  singular 元素，则该字段将设置为该字段的默认值，不同类型的默认值如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">字符串</td>
<td style="text-align:left">空串</td>
</tr>
<tr>
<td style="text-align:left">byte</td>
<td style="text-align:left">空 bytes</td>
</tr>
<tr>
<td style="text-align:left">bool</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">数值类型</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">枚举类型</td>
<td style="text-align:left">第一个定义的枚举元素，其序号一定为 0</td>
</tr>
<tr>
<td style="text-align:left">message 类型</td>
<td style="text-align:left">该字段未设置，它的确切值取决于依赖的语言</td>
</tr>
</tbody>
</table>
<p>repeated  字段的默认值为空，通常是所依赖的语言中的空列表。另外如果将 message 字段显式设置为其默认值，则该值在传输时不会被序列化。</p>
<p>Note that for scalar message fields, once a message is parsed there’s no way of telling whether a field was explicitly set to the default value (for example whether a boolean was set to <code>false</code>) or just not set at all: you should bear this in mind when defining your message types. For example, don’t have a boolean that switches on some behaviour when set to <code>false</code> if you don’t want that behaviour to also happen by default.</p>
<h3 id="28-import"><a class="markdownIt-Anchor" href="#28-import"></a> 2.8 Import</h3>
<p>默认情况下，只能够使用导入的 .proto 文件中的内容。当你想要移动某个 .proto 文件的位置，那么就得手动修改所有关于该文件的 import 【注：如果 IDE 不能帮你智能修改的话，一个个改实在是麻烦，这一点在 Java 中也是一样】。</p>
<p>现在，除了修改所有 import 路径外，多了一个新的选择。就是在原始位置放置一个虚拟的 .proto 文件，在这个 .proto 中使用 <code>import public</code> 将所有的 import 转发到新的位置中，调用者就可以传递导入新的位置中的内容【注：这有点类似于 Linux 的软链接，使用该功能后，旧的 .proto 文件就相当于一个快捷方式，会链接到新的 .proto 文件】。例如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new.proto</span></span><br><span class="line"><span class="comment">// All definitions are moved here</span></span><br></pre></td></tr></table></figure>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// old.proto</span></span><br><span class="line"><span class="comment">// This is the proto that all clients are importing.</span></span><br><span class="line"><span class="keyword">import</span> public <span class="string">&quot;new.proto&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;other.proto&quot;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.proto</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;old.proto&quot;</span>;</span><br><span class="line"><span class="comment">// You use definitions from old.proto and new.proto, but not other.proto</span></span><br></pre></td></tr></table></figure>
<p>Protobuf 使用<code>-I</code> 或 <code>--proto_path</code> 参数在 Protobuf 命令行中指定的一组目录中搜索导入的文件。如果未指定参数，它将在调用编译器的目录中查找。通常，应将 <code>--proto_path</code> 标志设置为项目的根目录，并对所有导入使用完全限定的名称【注：如果使用 <code>protobuf-maven-plugin</code> 插件，那么默认扫描路径是：<code>src/main/proto</code>】。</p>
<h2 id="三-message-更新"><a class="markdownIt-Anchor" href="#三-message-更新"></a> 三、Message 更新</h2>
<p>如果发现以前定义 message 需要增加字段了，这个时候就体现出 Protobuf 的优势了——不需要改动之前的代码。不过需要满足以下规则：</p>
<ul>
<li>
<p>不要改动原有字段的数据结构。</p>
</li>
<li>
<p>添加新字段，则任何由代码使用“旧”消息格式序列化的消息仍然可以通过新生成的代码进行分析。你应该记住这些元素的默认值，以便新代码可以正确地与旧代码生成的消息进行交互。同样，由新代码创建的消息可以由旧代码解析，旧的二进制文件在解析时会简单地忽略新字段。（具体原因见<a href="#%E5%9B%9B%E3%80%81%E6%9C%AA%E7%9F%A5%E5%AD%97%E6%AE%B5">第四章</a>）</p>
</li>
<li>
<p>只要字段在更新后的消息类型中不再使用，就可以删除。你可能会重命名，会添加前缀“OBSOLETE_”，或者标记成保留字段号 <code>reserved</code>，以便将来的 <code>.proto</code> 不会意外重复使用该字段号。</p>
</li>
<li>
<p>int32，uint32，int64，uint64 和 bool 全都兼容。这意味着你可以将字段从这些类型之一更改为另一个字段而不破坏向前或向后兼容性。如果一个数字从不适合相应类型的线路中解析出来，则会得到与在 C++ 中将该数字转换为该类型相同的效果（例如，如果将 64 位数字读为 int32，它将被截断为 32 位）。</p>
</li>
<li>
<p>sint32 和 sint64 相互兼容，但与其他整数类型不兼容。</p>
</li>
<li>
<p>只要字节是有效的UTF-8，string 和 bytes 是兼容的。</p>
</li>
<li>
<p>如果 bytes 包含 message 的 encoded version，则 Embedded message 与 bytes 兼容。</p>
</li>
<li>
<p>fixed32 与 sfixed32 兼容，fixed64 与 sfixed64 兼容。</p>
</li>
<li>
<p>enum 就数组而言，是可以与 int32，uint32，int64 和 uint64 兼容（请注意，如果它们不适合，值将被截断）。但是，当消息反序列化时，客户端代码可能会以不同的方式对待它们：例如，未识别的 proto3 枚举类型将保留在消息中，但消息反序列化时如何表示是与语言相关的。Int 域始终只保留它们的值。</p>
</li>
<li>
<p>Changing a single value into a member of a <strong>new</strong> <code>oneof</code> is safe and binary compatible. Moving multiple fields into a new <code>oneof</code> may be safe if you are sure that no code sets more than one at a time. Moving any fields into an existing <code>oneof</code> is not safe.</p>
</li>
</ul>
<h2 id="四-未知字段"><a class="markdownIt-Anchor" href="#四-未知字段"></a> 四、未知字段</h2>
<p>未知字段是格式正确的 Protobuf 序列化数据，表示解析器无法识别的字段。例如，当一个旧的二进制文件解析由新的二进制文件发送的新数据的数据时，这些新的字段将成为旧的二进制文件中的未知字段。</p>
<p>最初，Proto3 message 始终在解析过程中丢弃未知字段，但在 3.5 版本中，我们重新引入了保留未知字段以匹配 Proto2 行为的功能。在 3.5 版本和更高版本中，未知字段将在解析期间保留并包含在序列化输出中。</p>
<h2 id="五-any"><a class="markdownIt-Anchor" href="#五-any"></a> 五、Any</h2>
<p><code>Any</code>  可以将 message 用作嵌入类型，而无需定义它们的 .proto。<code>Any</code> 包含任意序列化的 message（以字节为单位），以及用作该 message 的类型的全局唯一标识符的 URL。要使用 <code>Any</code> ，需要 import <code>google/protobuf/any.proto</code>。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/any.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ErrorStatus</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">  <span class="title">repeated</span> google.protobuf.Any details = 2;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<p>给定 message 类型的默认类型 URL 为 <code>type.googleapis.com/packagename.messagename</code>。</p>
<p>不同的语言实现将支持运行时库帮助程序以类型安全的方式打包和解压缩任何值。例如，在 Java 中，Any 类型将具有特殊的<code>pack()</code> 和 <code>unpack()</code> 访问器，在 C++ 中有 <code>PackFrom()</code> 和 <code>UnpackTo()</code> 方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Storing an arbitrary message type in Any.</span></span><br><span class="line">NetworkErrorDetails details = ...;</span><br><span class="line">ErrorStatus status;</span><br><span class="line">status.<span class="built_in">add_details</span>()-&gt;<span class="built_in">PackFrom</span>(details);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reading an arbitrary message from Any.</span></span><br><span class="line">ErrorStatus status = ...;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> Any&amp; detail : status.<span class="built_in">details</span>()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (detail.Is&lt;NetworkErrorDetails&gt;()) &#123;</span><br><span class="line">    NetworkErrorDetails network_error;</span><br><span class="line">    detail.<span class="built_in">UnpackTo</span>(&amp;network_error);</span><br><span class="line">    ... processing network_error ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六-oneof"><a class="markdownIt-Anchor" href="#六-oneof"></a> 六、Oneof</h2>
<p>如果某个 message 包含许多字段，但是最多可以同时设置一个字段，则可以使用 oneof 功能强制执行此行为并节省内存。</p>
<p>除了共享内存中的所有字段外，oneof 字段与常规字段类似，最多可以同时设置一个字段。设置 oneof 中的任何成员会自动清除所有其他字段。你可以使用 <code>case()</code> 或者 <code>WhichOneof()</code>方法来检查 oneof 中的哪个有值，具体取决于您选择的语言。</p>
<h3 id="61-using-oneof"><a class="markdownIt-Anchor" href="#61-using-oneof"></a> 6.1 Using Oneof</h3>
<p>要使用 oneof，只要 oneof 关键字加上 oneof 名称即可，在下面的例子中是 <code>test_oneof</code>：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SampleMessage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">oneof</span> test_oneof &#123;</span><br><span class="line">    <span class="built_in">string</span> name = <span class="number">4</span>;</span><br><span class="line">    SubMessage sub_message = <span class="number">9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后添加字段到 oneof 定义中，你可以添加任何类型的字段，但不能使用重复的字段。在生成的代码中，oneof 字段具有与常规字段相同的 getter 和 setter。你还能通过一种特殊的方法来检查 oneof 中的哪个有值。</p>
<h3 id="62-oneof-features"><a class="markdownIt-Anchor" href="#62-oneof-features"></a> 6.2 Oneof Features</h3>
<ul>
<li>
<p>设置 oneof 字段将自动清除 oneof 的所有其他字段。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SampleMessage message;</span><br><span class="line">message.<span class="built_in">set_name</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="built_in">CHECK</span>(message.<span class="built_in">has_name</span>());</span><br><span class="line">message.<span class="built_in">mutable_sub_message</span>();   <span class="comment">// Will clear name field.</span></span><br><span class="line"><span class="built_in">CHECK</span>(!message.<span class="built_in">has_name</span>());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果 Protobuf 解析器解析 oneof 时发现了多个有值的字段，则仅最后一个字段有效。</p>
</li>
<li>
<p>oneof 字段不能是 <code>repeated</code>。</p>
</li>
<li>
<p>oneof 字段可以使用反射 API。</p>
</li>
<li>
<p>如果将 oneof 字段设置为 message 默认值（例如设置 int32 oneof 字段为 0），the “case” of that oneof field will be set, and the value will be serialized on the wire.</p>
</li>
<li>
<p>如果你使用的是 C++，请确保你的代码不会导致内存崩溃。以下示例代码将崩溃，因为通过调用 set_name() 方法时已经删除了 sub_message。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SampleMessage message;</span><br><span class="line">SubMessage* sub_message = message.<span class="built_in">mutable_sub_message</span>();</span><br><span class="line">message.<span class="built_in">set_name</span>(<span class="string">&quot;name&quot;</span>);      <span class="comment">// Will delete sub_message</span></span><br><span class="line">sub_message-&gt;set_...            <span class="comment">// Crashes here</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>还是在 C++，如果使用 <code>Swap()</code> 了两个有 oneof 字段的 message，each message will end up with the other’s oneof case。例如，<code>msg1</code> 会有一个 <code>sub_message</code> 而 <code>msg2</code> 会有一个 <code>name</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SampleMessage msg1;</span><br><span class="line">msg1.<span class="built_in">set_name</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">SampleMessage msg2;</span><br><span class="line">msg2.<span class="built_in">mutable_sub_message</span>();</span><br><span class="line">msg1.<span class="built_in">swap</span>(&amp;msg2);</span><br><span class="line"><span class="built_in">CHECK</span>(msg1.<span class="built_in">has_sub_message</span>());</span><br><span class="line"><span class="built_in">CHECK</span>(msg2.<span class="built_in">has_name</span>());</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="63-向后兼容"><a class="markdownIt-Anchor" href="#63-向后兼容"></a> 6.3 向后兼容</h3>
<p>添加或删除 oneof 字段时时请多加注意。如果检查 oneof 的值返回 <code>None / NOT_SET</code>，则可能意味着 oneof 尚未设置或已被设置为 oneof 的不同版本中的字段。由于无法知道传输时的未知字段是否是 oneof 的成员，因此无法分辨出差异。</p>
<p><strong>标签重用问题：</strong></p>
<ul>
<li><strong>将字段移入或移出 oneof：</strong> message 被序列化和解析后，可能会丢失一些信息（某些字段将被清除）。但是可以安全地将单个字段移动到新字段中。</li>
<li><strong>删除一个 oneof 字段并添加它返回：</strong> 在 message 被序列化和解析之后，这可能会清除你当前设置的 oneof 字段。</li>
<li><strong>拆分或合并：</strong> 这与移动常规字段有类似的问题。</li>
</ul>
<h2 id="七-map"><a class="markdownIt-Anchor" href="#七-map"></a> 七、Map</h2>
<p>repeated 类型可以用来表示数组，而想要表示字典可以用 Map 类型。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;key_type, value_type&gt; map_field = N;</span><br></pre></td></tr></table></figure>
<p><code>key_type</code> 可以是 int 或者 string 类型，不能是 float、double、bytes 和枚举。<code>value_type</code> 可以是除 map 外的任何类型。举个例子：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="built_in">string</span>, Project&gt; projects = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>需要特别注意的是 ：</p>
<ul>
<li>map 是不能用 <code>repeated</code> 修饰的。</li>
<li>线性数组和 map 迭代顺序的是不确定的，所以你不能依靠你的 map 是在一个特定的顺序。</li>
<li>为 <code>.proto</code> 生成文本格式时，map 按 key 排序。数字类型 key 按数值排序。</li>
<li>从 wire 中解析或合并时，如果有重复的 key，则最后一个 key 有效（覆盖原则）。从文本格式解析 map 时，如果有重复的 key，解析可能会失败。</li>
<li>如果往 map 中放了一个没有 value 的 key，字段被序列化时的行为取决于具体的语言。在C ++、Java 和 Python 中，类型的默认值是序列化的，而在其他语言中则没有序列化的值。</li>
</ul>
<p>Protobuf 虽然不支持 map 类型的数组，但是可以转换一下，用 repeated 实现 maps 数组：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MapFieldEntry</span> </span>&#123;</span><br><span class="line">  key_type key = <span class="number">1</span>;</span><br><span class="line">  value_type value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">repeated</span> MapFieldEntry map_field = N;</span><br></pre></td></tr></table></figure>
<h2 id="八-package"><a class="markdownIt-Anchor" href="#八-package"></a> 八、Package</h2>
<p>你可以在 .proto 文件中添加可选的 package 说明符，以防 message 之间的名称冲突。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo.bar;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Open</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>然后，可以在定义 message 的字段时使用包说明符：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  foo.bar.Open open = <span class="number">1</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>package 编译成具体的代码后，将根据使用语言的不同有不同的实现。对于 Java，将会被用作 Java package，除非你的 .proto 文件中存在明确的 <code>option java_package</code> 定义，<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/proto3#packages">点击这里</a>查看其他语言。</p>
<h2 id="九-service"><a class="markdownIt-Anchor" href="#九-service"></a> 九、Service</h2>
<p>如果要使用 RPC（远程过程调用），可以在 <code>.proto</code> 文件中定义 RPC 服务接口，Protobuf 编译器将使用所选语言生成服务接口代码和 stubs。例如，如果你定义一个 RPC 服务，入参是 SearchRequest 返回值是 SearchResponse，你可以在你的 <code>.proto</code> 文件中定义它，如下所示：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">SearchService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Search (SearchRequest) <span class="keyword">returns</span> (SearchResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 Protobuf 一起使用的最直接的 RPC 系统是 <code>gRPC</code><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。gRPC 可以和 Protobuf 无缝结合，甚至允许你通过 Protobuf 编译插件，直接从 <code>.proto</code> 文件中生成 RPC 相关的代码。</p>
<p>还有许多正在进行的第三方项目正在为 Protobuf 开发RPC实现，了解相关内容： <a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf/blob/master/docs/third_party.md">third-party add-ons wiki page</a>。</p>
<h2 id="十-json-mapping"><a class="markdownIt-Anchor" href="#十-json-mapping"></a> 十、JSON Mapping</h2>
<p>Proto3 支持 JSON 中的标准编码， 让在系统之间分享数据变得容易 。编码在下表中按类型逐个描述。</p>
<p>如果一个值在 JSON 编码的数据中丢失或者它的值是 null，则在解析为 Protobuf 时，它将被解析为对应默认值。如果一个字段在 Protobuf 中具有默认值，默认情况下它将不会出现在 JSON 编码数据中以节省空间。 具体实现应该提供选项来在 JSON 编码输出中出现带有默认值的字段.</p>
<table>
<thead>
<tr>
<th style="text-align:left">proto3</th>
<th style="text-align:left">JSON</th>
<th style="text-align:left">JSON example</th>
<th style="text-align:left">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">message</td>
<td style="text-align:left">object</td>
<td style="text-align:left"><code>&#123;&quot;fooBar&quot;: v,&quot;g&quot;: null,…&#125;</code></td>
<td style="text-align:left">生成 JSON 对象。message 字段名被转换为小驼峰并成为 JSON 对象的 key。如果指定了<code>json_name</code> 字段选项，则将指定的值用作键。解析器接受小驼峰名称（或由 <code>json_name</code> 选项指定的名称）和原始 protobuf 字段名称。<code>null</code> 是所有字段类型的可接受值，并被视为相应字段类型的默认值。</td>
</tr>
<tr>
<td style="text-align:left">enum</td>
<td style="text-align:left">string</td>
<td style="text-align:left"><code>&quot;FOO_BAR&quot;</code></td>
<td style="text-align:left">使用在 Protobuf 中指定的枚举值的名称，解析器接受枚举名称和整数值。</td>
</tr>
<tr>
<td style="text-align:left">map&lt;K,V&gt;</td>
<td style="text-align:left">object</td>
<td style="text-align:left"><code>&#123;&quot;k&quot;: v, …&#125;</code></td>
<td style="text-align:left">所有键都转换为字符串。</td>
</tr>
<tr>
<td style="text-align:left">repeated V</td>
<td style="text-align:left">array</td>
<td style="text-align:left"><code>[v, …]</code></td>
<td style="text-align:left"><code>null</code> 被接收且被转换为空 List。</td>
</tr>
<tr>
<td style="text-align:left">bool</td>
<td style="text-align:left">true, false</td>
<td style="text-align:left"><code>true, false</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">string</td>
<td style="text-align:left">string</td>
<td style="text-align:left"><code>&quot;Hello World!&quot;</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">bytes</td>
<td style="text-align:left">base64 string</td>
<td style="text-align:left"><code>&quot;YWJjMTIzIT8kKiYoKSctPUB+&quot;</code></td>
<td style="text-align:left">JSON 值将使用标准 base64 编码成字符串，接受带&quot;/&quot;不带paddings 的标准或 URL 安全的 base64 编码。</td>
</tr>
<tr>
<td style="text-align:left">int32, fixed32, uint32</td>
<td style="text-align:left">number</td>
<td style="text-align:left"><code>1, -10, 0</code></td>
<td style="text-align:left">JSON 值为十进制数字，接受数字或字符串。</td>
</tr>
<tr>
<td style="text-align:left">int64, fixed64, uint64</td>
<td style="text-align:left">string</td>
<td style="text-align:left"><code>&quot;1&quot;, &quot;-10&quot;</code></td>
<td style="text-align:left">JSON 值将是一个十进制字符串，接受数字或字符串。</td>
</tr>
<tr>
<td style="text-align:left">float, double</td>
<td style="text-align:left">number</td>
<td style="text-align:left"><code>1.1, -10.0, 0, &quot;NaN&quot;, &quot;Infinity&quot;</code></td>
<td style="text-align:left">JSON 值将是数字或特殊字符串值“NaN”、“ Infinity”或“ -Infinity”。接受数字或字符串。指数表示法也被接受。</td>
</tr>
<tr>
<td style="text-align:left">Any</td>
<td style="text-align:left"><code>object</code></td>
<td style="text-align:left"><code>&#123;&quot;@type&quot;: &quot;url&quot;, &quot;f&quot;: v, … &#125;</code></td>
<td style="text-align:left">如果 Any 包含具有特殊 JSON 映射的值，它将被转换成：<code>&#123;&quot;@type&quot;: xxx, &quot;value&quot;: yyy&#125;</code>。否则，该值将转换为 JSON 对象，“ @type”字段为实际的数据类型。</td>
</tr>
<tr>
<td style="text-align:left">Timestamp</td>
<td style="text-align:left">string</td>
<td style="text-align:left"><code>&quot;1972-01-01T10:00:20.021Z&quot;</code></td>
<td style="text-align:left">使用 RFC 3339，其中生成的输出将始终进行 Z 归一化，并使用 0、3、6 或 9 个小数位。也可以接受“ Z”以外的偏移。</td>
</tr>
<tr>
<td style="text-align:left">Duration</td>
<td style="text-align:left">string</td>
<td style="text-align:left"><code>&quot;1.000340012s&quot;, &quot;1s&quot;</code></td>
<td style="text-align:left">生成的输出始终包含 0、3、6 或 9 个小数位数，具体取决于所需的精度，后跟后缀“ s”。可接受的任何小数位数，只要它们适合纳秒精度，后缀“ s”是必需的。</td>
</tr>
<tr>
<td style="text-align:left">Struct</td>
<td style="text-align:left"><code>object</code></td>
<td style="text-align:left"><code>&#123; … &#125;</code></td>
<td style="text-align:left">任何 JSON 对象，见 <code>struct.proto</code>。</td>
</tr>
<tr>
<td style="text-align:left">Wrapper types</td>
<td style="text-align:left">various types</td>
<td style="text-align:left"><code>2, &quot;2&quot;, &quot;foo&quot;, true, &quot;true&quot;, null, 0, …</code></td>
<td style="text-align:left">Wrapper 在 JSON 中使用与包装后的原始类型相同的表示形式，不同之处在于在数据转换和传输期间允许保留 <code>null</code>。</td>
</tr>
<tr>
<td style="text-align:left">FieldMask</td>
<td style="text-align:left">string</td>
<td style="text-align:left"><code>&quot;f.fooBar,h&quot;</code></td>
<td style="text-align:left">见<code>field_mask.proto</code>。</td>
</tr>
<tr>
<td style="text-align:left">ListValue</td>
<td style="text-align:left">array</td>
<td style="text-align:left"><code>[foo, bar, …]</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Value</td>
<td style="text-align:left">value</td>
<td style="text-align:left"></td>
<td style="text-align:left">任何 JSON 值。</td>
</tr>
<tr>
<td style="text-align:left">NullValue</td>
<td style="text-align:left">null</td>
<td style="text-align:left"></td>
<td style="text-align:left">JSON 为 null。</td>
</tr>
<tr>
<td style="text-align:left">Empty</td>
<td style="text-align:left">object</td>
<td style="text-align:left">{}</td>
<td style="text-align:left">一个空的 JSON 对象。</td>
</tr>
</tbody>
</table>
<p>Proto3 的 JSON 实现中提供了以下几种选项:</p>
<ul>
<li><strong>使用默认值发送字段</strong>：在默认情况下，默认值的字段在 Proto3 JSON 输出中被忽略。一个实现可以提供一个选项来覆盖这个行为，并使用它们的默认值输出字段。</li>
<li><strong>忽略未知字段</strong>：默认情况下，Proto3 JSON 解析器拒绝未知字段，但可能提供一个选项来忽略解析中的未知字段。</li>
<li><strong>使用 Protobuf 字段名称而不是转换为小驼峰后的名称</strong>：默认情况下，Proto3 JSON 的 printer 将字段名称转换为小驼峰并将其用作 JSON 名称。实现可能会提供一个选项，将原始字段名称用作 JSON 名称。 Proto3 JSON 解析器需要接受转换后的小驼峰名称和原始字段名称。</li>
<li><strong>将枚举值作为整数而不是字符串发送</strong> ：在 JSON 输出中默认使用枚举值的名称。可以提供一个选项来使用枚举值的数值。</li>
</ul>
<h2 id="十一-options"><a class="markdownIt-Anchor" href="#十一-options"></a> 十一、Options</h2>
<p>.proto 文件中的个别声明可以使用数据的 <code>option</code> 注解，option 不改变声明的整体意义, 但是在特定上下文会影响它被处理的方式。可用 option 的完整列表定义在 <code>google/protobuf/descriptor.proto</code> 。</p>
<p>有些 option  是 <strong>file 级别</strong>，意味着他们应该写在顶级范围，而不是在任何 message、枚举或者 Service 定义之内。有些 option  是 <strong>message 级别</strong>，意味着他们应该写在 message 定义内。有些选项是 <strong>field 级别</strong>,，意味着他们应该写在字段定义内。下面列出一些常用的 option：</p>
<ul>
<li>
<p><strong>java_package (file 级别)</strong>：希望生成的 Java 代码使用的 package。如果 .proto 文件中没有显式给出 <code>java_package</code> 选项, 则默认使用 proto package(.proto 文件中通过 “<code>package</code>” 关键字指定)。如果不生成 Java 代码，则此 option 不起作用。</p>
<p>proto package 通常不适合用作 java package，因为 Java 中的 package 形如反转域名，例如 <code>com.baidu.xxx</code>。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;com.example.foo&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>java_multiple_files (file 级别)</strong>：为 true 时，每个 message、枚举和 service 都会被生成为一个类，否则这些都会是 <code>java_outer_classname</code> 的内部类。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> java_multiple_files = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>java_outer_classname  (file 级别)</strong>：要生成的最外层 Java 类的类名（即文件名）。如果在<code>.proto</code>文件中没有指定明确的<code>java_outer_classname</code>，则通过将<code>.proto</code>文件名转换为大驼峰来构造类名称（例如<code>foo_bar.proto</code>变为<code>FooBar.java</code>）。 如果不生成Java代码，则此 option 不起作用。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;Ponycopter&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>optimize_for (file 级别)</strong>：可以设置为 SPEED、CODE_SIZE 或 LITE_RUNTIME。 或影响 C ++ 和 Java 代码生成器（以及可能的第三方生成器）的运行效率。</p>
<ul>
<li><code>SPEED</code> (默认)： Protobuf 编译器将生成用于对 message 类型进行序列化、解析和执行其他常见操作的代码，代码已经高度优化。</li>
<li><code>CODE_SIZE</code>：Protobuf 编译器会生成最少的类，会依赖共享的、基于反射的代码来实现序列化、解析和其他操作。生成的代码因此会比用 SPEED 生成的小很多，但是操作更慢一些。会提供和在 SPEED 模式下完全相同的API。这个模式主要用在包含非常多数量的 .proto 文件而又不需要他们都运行的极其快的应用中。【注： 生成的代码类最少，生成的总代码量也小，但是操作速度会变慢 】</li>
<li><code>LITE_RUNTIME</code>：Protobuf 编译器将生成仅依赖于“精简版”运行时库的类 (<code>libprotobuf-lite</code> 替代 <code>libprotobuf</code>)。 精简版运行时比完整库要小得多（大约小一个数量级），但省略了某些功能，例如  descriptors  和反射。 对于在受限平台（如手机）上运行的应用程序特别有用。编译器依然会生成所有方法的快速实现，如同在 SPEED 模式下一样。 生成的类将仅以每种语言实现 <code>MessageLite</code> 接口，它是完整 Message 接口方法的一个子集。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> optimize_for = CODE_SIZE;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>cc_enable_arenas (file 级别)</strong>：对于 C++ 代码生成开启  <a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/reference/arenas">arena allocation</a> 功能。</p>
</li>
<li>
<p><strong>objc_class_prefix  (file 级别)</strong>： Sets the Objective-C class prefix which is prepended to all Objective-C generated classes and enums from this .proto. There is no default. You should use prefixes that are between 3-5 uppercase characters as <a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html#//apple_ref/doc/uid/TP40011210-CH10-SW4">recommended by Apple</a>. Note that all 2 letter prefixes are reserved by Apple.</p>
</li>
<li>
<p><strong>deprecated  (field 级别)</strong>： 如果设置为 true，表明这个字段被废弃，新代码不应该再使用。在大多数语言中这不会有实质影响。在 Java 中，这将会变成一个 <code>@Deprecated</code> 标签。 未来在其他特定语言的代码生成器可能在字段的访问器上生成废弃标签，在编译试图使用这个字段的代码时会生成警告。如果这个字段不再被任何人使用而你想阻止新用户使用它，可以考虑将字段声明替换为保留字段。</p>
</li>
</ul>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Protobuf，即 Google Protocol Buffers，协议缓冲区。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>在 Java 中，无符号的 32 位和 64 位整数使用带符号的对等体表示，最高位仅存储在符号位中。 <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a> <a href="#fnref2:2" class="footnote-backref">↩︎</a> <a href="#fnref2:3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>gRPC，谷歌开发的语言和平台中立的开源 RPC 系统 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Jitwxs</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jitwxs.cn/60aca815.html">https://jitwxs.cn/60aca815.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jitwxs.cn" target="_blank">Jitwxs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Protobuf/">Protobuf</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/top/cover16.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/configuration/wechat_donate.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/configuration/wechat_donate.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/configuration/alipay_donate.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/configuration/alipay_donate.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/d4225e9b.html"><img class="prev-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/top/cover11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Protobuf 学习手册——编码篇</div></div></a></div><div class="next-post pull-right"><a href="/a5b690ac.html"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/top/cover5.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Protobuf 在 Java 中的入门实例</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/a5b690ac.html" title="Protobuf 在 Java 中的入门实例"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/top/cover5.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-23</div><div class="title">Protobuf 在 Java 中的入门实例</div></div></a></div><div><a href="/d6535904.html" title="gRPC 在 Java 中的入门实例"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/top/cover7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-26</div><div class="title">gRPC 在 Java 中的入门实例</div></div></a></div><div><a href="/d4225e9b.html" title="Protobuf 学习手册——编码篇"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/top/cover11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-26</div><div class="title">Protobuf 学习手册——编码篇</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/configuration/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Jitwxs</div><div class="author-info__description">不忘初心，砥砺前行</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">224</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">132</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">39</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jitwxs"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/jitwxs" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=Ujg7JiUqIRI0PSo-Mzs_fDE9Pw" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a><a class="social-icon" href="https://jitwxs.blog.csdn.net" target="_blank" title="CSDN"><i class="fab fa-cuttlefish flat-btn"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">专注 Java 后端开发，内容涵盖 SpringBoot、并发编程、微服务、容器化、Linux 等技术分享。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-override"><span class="toc-text"> 一、Override</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8F%91%E6%98%8E-protobuf"><span class="toc-text"> 1.1 为什么要发明 Protobuf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%91%BD%E5%90%8D%E7%94%B1%E6%9D%A5"><span class="toc-text"> 1.2 命名由来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-proto2-or-proto3"><span class="toc-text"> 1.3 Proto2 or Proto3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%AF%B9%E6%AF%94-xml"><span class="toc-text"> 1.4 对比 XML</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97"><span class="toc-text"> 1.5 学习指南</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-message-%E5%AE%9A%E4%B9%89"><span class="toc-text"> 二、Message 定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 2.1 字段类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#211-%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 2.1.1  基础类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#212-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 2.1.2 枚举类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#213-message-%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 2.1.3 Message 类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%AD%97%E6%AE%B5%E7%BC%96%E5%8F%B7"><span class="toc-text"> 2.2 字段编号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E5%AD%97%E6%AE%B5%E8%A7%84%E5%88%99"><span class="toc-text"> 2.3 字段规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA-message"><span class="toc-text"> 2.4 添加多个 Message</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E6%B3%A8%E9%87%8A"><span class="toc-text"> 2.5 注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E4%BF%9D%E7%95%99%E5%AD%97%E6%AE%B5"><span class="toc-text"> 2.6 保留字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-text"> 2.7 默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-import"><span class="toc-text"> 2.8 Import</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-message-%E6%9B%B4%E6%96%B0"><span class="toc-text"> 三、Message 更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E6%9C%AA%E7%9F%A5%E5%AD%97%E6%AE%B5"><span class="toc-text"> 四、未知字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-any"><span class="toc-text"> 五、Any</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-oneof"><span class="toc-text"> 六、Oneof</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#61-using-oneof"><span class="toc-text"> 6.1 Using Oneof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-oneof-features"><span class="toc-text"> 6.2 Oneof Features</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9"><span class="toc-text"> 6.3 向后兼容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-map"><span class="toc-text"> 七、Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-package"><span class="toc-text"> 八、Package</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D-service"><span class="toc-text"> 九、Service</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81-json-mapping"><span class="toc-text"> 十、JSON Mapping</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-options"><span class="toc-text"> 十一、Options</span></a></li></ol></div></div><div class="card-widget card-post-link"><div class="card-content"><div class="item-headline"><i class="fas fa-book"></i><span>参考资料</span></div><div class="aside-list"><div class="aside-list-item"><div class="content"><a class="title" target="_blank" rel="noopener" href="https://halfrost.com/protobuf_encode" title="高效的数据压缩编码方式 Protobuf">高效的数据压缩编码方式 Protobuf</a></div></div><div class="aside-list-item"><div class="content"><a class="title" target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/proto3" title="Language Guide (proto3)">Language Guide (proto3)</a></div></div><div class="aside-list-item"><div class="content"><a class="title" target="_blank" rel="noopener" href="https://www.cntofu.com/book/116/index.html" title="Protocol Buffer 3学习笔记">Protocol Buffer 3学习笔记</a></div></div><div class="aside-list-item"><div class="content"><a class="title" target="_blank" rel="noopener" href="https://juejin.im/post/59361f79a22b9d0058fdc725" title="Protocol Buffers 学习（6）：文件 | 字段选项介绍">Protocol Buffers 学习（6）：文件 | 字段选项介绍</a></div></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/e4d53ddb.html" title="Spring SchedulingConfigurer 实现动态定时任务"><img data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/top/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring SchedulingConfigurer 实现动态定时任务"/></a><div class="content"><a class="title" href="/e4d53ddb.html" title="Spring SchedulingConfigurer 实现动态定时任务">Spring SchedulingConfigurer 实现动态定时任务</a><time datetime="2021-03-27T15:23:41.000Z" title="发表于 2021-03-27 23:23:41">2021-03-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/9f878221.html" title="Java 双亲委派机制"><img data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/top/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java 双亲委派机制"/></a><div class="content"><a class="title" href="/9f878221.html" title="Java 双亲委派机制">Java 双亲委派机制</a><time datetime="2021-03-14T03:26:34.000Z" title="发表于 2021-03-14 11:26:34">2021-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/bef70352.html" title="图解 | 你管这破玩意儿叫TCP？"><img data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/top/cover13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="图解 | 你管这破玩意儿叫TCP？"/></a><div class="content"><a class="title" href="/bef70352.html" title="图解 | 你管这破玩意儿叫TCP？">图解 | 你管这破玩意儿叫TCP？</a><time datetime="2021-01-24T07:19:23.000Z" title="发表于 2021-01-24 15:19:23">2021-01-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/c376af5e.html" title="图解 | 你管这破玩意叫线程池？"><img data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/top/cover21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="图解 | 你管这破玩意叫线程池？"/></a><div class="content"><a class="title" href="/c376af5e.html" title="图解 | 你管这破玩意叫线程池？">图解 | 你管这破玩意叫线程池？</a><time datetime="2021-01-23T11:23:54.000Z" title="发表于 2021-01-23 19:23:54">2021-01-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/93fdc2b.html" title="如果让你来设计网络"><img data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/top/cover1.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如果让你来设计网络"/></a><div class="content"><a class="title" href="/93fdc2b.html" title="如果让你来设计网络">如果让你来设计网络</a><time datetime="2021-01-23T07:39:03.000Z" title="发表于 2021-01-23 15:39:03">2021-01-23</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(135deg,"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2021 By Jitwxs</div><div class="footer_custom_text"><a target="_blank" rel="noopener" href='http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action'><img class='icp-icon entered loading' src='/img/icp.png' alt='ICP' data-ll-status='loading'>苏 ICP 备 16061429 号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    let id = md5(decodeURI(window.location.pathname));
    var gitalk = new Gitalk(Object.assign({
      clientID: '1abf6b8c844664e07e3e',
      clientSecret: '49e497f91b34805a5d19dd73b6d4493d84020782',
      repo: 'blog-comment',
      owner: 'jitwxs',
      admin: ['jitwxs'],
      id: id,
      language: 'en',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const findTrueUrl = (array) => {
    let url = ''
    Promise.all(array.map(item =>
      fetch(item.url).then(resp => resp.json()).then(data => {
        if (data.user.login === 'utterances-bot') {
          url = data.body.match(/https?\:\/\/[^\" ]+/ig).slice(-1)
          return url[0]
        } else {
          url = data.body.match(/https?\:\/\/[^\" ]+/i)
          return url[0]
        }
      })
    )).then(res => {
        array = array.map((i,index)=> {
          return {
            ...i,
            url: res[index]
          }
        })

        saveToLocal.set('github-newest-comments', JSON.stringify(array), 10/(60*24))
        generateHtml(array)
    });
  }

  const getComment = () => {
    fetch('https://api.github.com/repos/jitwxs/blog-comment/issues/comments?sort=updated&direction=desc&per_page=6&page=1',{
      "headers": {
        Accept: 'application/vnd.github.v3.html+json'
      }
    })
      .then(response => response.json())
      .then(data => {
        const githubArray = data.map(item => {
          return {
            'avatar': item.user.avatar_url,
            'content': changeContent(item.body_html),
            'nick': item.user.login,
            'url': item.issue_url,
            'date': item.updated_at,
            'githubUrl': item.html_url
          }
        })
        findTrueUrl(githubArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      })
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('github-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="5273081683" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" data-lrctype="1" muted></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.17.0/js/md5.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: true,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', 'G-40VH67TNSM', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>