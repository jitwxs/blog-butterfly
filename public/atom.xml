<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jitwxs</title>
  
  
  <link href="https://jitwxs.cn/atom.xml" rel="self"/>
  
  <link href="https://jitwxs.cn/"/>
  <updated>2021-04-04T07:40:42.678Z</updated>
  <id>https://jitwxs.cn/</id>
  
  <author>
    <name>Jitwxs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring SchedulingConfigurer 实现动态定时任务</title>
    <link href="https://jitwxs.cn/e4d53ddb.html"/>
    <id>https://jitwxs.cn/e4d53ddb.html</id>
    <published>2021-03-27T15:23:41.000Z</published>
    <updated>2021-04-04T07:40:42.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言"></a> 一、前言</h2><p>大家在日常工作中，一定使用过 Spring 的 <code>@Scheduled</code> 注解吧，通过该注解可以非常方便的帮助我们实现任务的定时执行。</p><p>但是该注解是不支持运行时动态修改执行间隔的，不知道你在业务中有没有这些需求和痛点：</p><ul><li>在服务运行时能够动态修改定时任务的执行频率和执行开关，而无需重启服务和修改代码</li><li>能够基于配置，在不同环境/机器上，实现定时任务执行频率的差异化</li></ul><p>这些都可以通过 Spring 的 <code>SchedulingConfigurer</code> 注解来实现。</p><p>这个注解其实大家并不陌生，如果有使用过 @Scheduled 的话，因为 @Scheduled 默认是单线程执行的，因此如果存在多个任务同时触发，可能触发阻塞。使用 SchedulingConfigurer 可以配置用于执行 @Scheduled 的线程池，来避免这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleConfig</span> <span class="keyword">implements</span> <span class="title">SchedulingConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设定一个长度10的定时任务线程池</span></span><br><span class="line">        taskRegistrar.setScheduler(Executors.newScheduledThreadPool(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但其实这个接口，还可以实现动态定时任务的功能，下面来演示如何实现。</p><h2 id="二-功能实现"><a class="markdownIt-Anchor" href="#二-功能实现"></a> 二、功能实现</h2><blockquote><p>后续定义的类开头的 <code>DS</code> 是 <code>Dynamic Schedule</code> 的缩写。</p></blockquote><p>使用到的依赖，除了 Spring 外，还包括：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="21-enablescheduling"><a class="markdownIt-Anchor" href="#21-enablescheduling"></a> 2.1 @EnableScheduling</h3><p>首先需要开启 <code>@EnableScheduling</code> 注解，直接在启动类添加即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DSApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DSApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-idstaskinfo"><a class="markdownIt-Anchor" href="#22-idstaskinfo"></a> 2.2 IDSTaskInfo</h3><p>定义一个任务信息的接口，后续所有用于动态调整的任务信息对象，都需要实现该接口。</p><ul><li><code>id</code>：该任务信息的唯一 ID，用于唯一标识一个任务</li><li><code>cron</code>：该任务执行的 cron 表达式。</li><li><code>isValid</code>：任务开关</li><li><code>isChange</code>：用于标识任务参数是否发生了改变</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDSTaskInfo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务 ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务执行 cron 表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getCron</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务是否有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断任务是否发生变化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isChange</span><span class="params">(IDSTaskInfo oldTaskInfo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-dscontainer"><a class="markdownIt-Anchor" href="#23-dscontainer"></a> 2.3 DSContainer</h3><p>顾名思义，是存放 IDSTaskInfo 的容器。</p><p>具有以下成员变量：</p><ul><li><code>scheduleMap</code>：用于暂存 IDSTaskInfo 和实际任务 ScheduledTask 的映射关系。其中：<ul><li>task_id：作为主键，确保一个 IDSTaskInfo 只会被注册进一次</li><li>T：暂存当初注册时的 IDSTaskInfo，用于跟最新的 IDSTaskInfo 比较参数是否发生变化</li><li>ScheduledTask：暂存当初注册时生成的任务，如果需要取消任务的话，需要拿到该对象</li><li>Semaphore：确保每个任务实际执行时只有一个线程执行，不会产生并发问题</li></ul></li><li><code>taskRegistrar</code>：Spring 的任务注册管理器，用于注册任务到 Spring 容器中</li><li><code>name</code>：调用方提供的类名</li></ul><p>具有以下成员方法：</p><ul><li><code>void checkTask(final T taskInfo, final TriggerTask triggerTask)</code>：检查 IDSTaskInfo，判断是否需要注册/取消任务。具体的逻辑包括：<ul><li>如果任务已经注册：<ul><li>如果任务无效：则取消任务</li><li>如果任务有效：<ul><li>如果任务配置发生了变化：则取消任务并重新注册任务</li></ul></li></ul></li><li>如果任务没有注册：<ul><li>如果任务有效：则注册任务</li></ul></li></ul></li><li><code>Semaphore getSemaphore()</code>：获取信号量属性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.tuple.Pair;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.config.ScheduledTask;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.config.ScheduledTaskRegistrar;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.config.TriggerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存放 IDSTaskInfo 容器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jitwxs</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年03月27日 16:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DSContainer</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">IDSTaskInfo</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IDSTaskInfo和真实任务的关联关系</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;task_id, &lt;Task, &lt;Scheduled, Semaphore&gt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, Pair&lt;T, Pair&lt;ScheduledTask, Semaphore&gt;&gt;&gt; scheduleMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledTaskRegistrar taskRegistrar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DSContainer</span><span class="params">(ScheduledTaskRegistrar scheduledTaskRegistrar, <span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskRegistrar = scheduledTaskRegistrar;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> taskInfo 任务信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> triggerTask 任务的触发规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkTask</span><span class="params">(<span class="keyword">final</span> T taskInfo, <span class="keyword">final</span> TriggerTask triggerTask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> taskId = taskInfo.getId();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (scheduleMap.containsKey(taskId)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (taskInfo.isValid()) &#123;</span><br><span class="line">                <span class="keyword">final</span> T oldTaskInfo = scheduleMap.get(taskId).getLeft();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(oldTaskInfo.isChange(taskInfo)) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;DSContainer will register &#123;&#125; again because task config change, taskId: &#123;&#125;&quot;</span>, name, taskId);</span><br><span class="line">                    cancelTask(taskId);</span><br><span class="line">                    registerTask(taskInfo, triggerTask);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;DSContainer will cancelTask &#123;&#125; because task not valid, taskId: &#123;&#125;&quot;</span>, name, taskId);</span><br><span class="line">                cancelTask(taskId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (taskInfo.isValid()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;DSContainer will register &#123;&#125; task, taskId: &#123;&#125;&quot;</span>, name, taskId);</span><br><span class="line">                registerTask(taskInfo, triggerTask);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 Semaphore，确保任务不会被多个线程同时执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Semaphore <span class="title">getSemaphore</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> taskId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.scheduleMap.get(taskId).getRight().getRight();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerTask</span><span class="params">(<span class="keyword">final</span> T taskInfo, <span class="keyword">final</span> TriggerTask triggerTask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ScheduledTask latestTask = taskRegistrar.scheduleTriggerTask(triggerTask);</span><br><span class="line">        <span class="keyword">this</span>.scheduleMap.put(taskInfo.getId(), Pair.of(taskInfo, Pair.of(latestTask, <span class="keyword">new</span> Semaphore(<span class="number">1</span>))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelTask</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> taskId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Pair&lt;T, Pair&lt;ScheduledTask, Semaphore&gt;&gt; pair = <span class="keyword">this</span>.scheduleMap.remove(taskId);</span><br><span class="line">        <span class="keyword">if</span> (pair != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pair.getRight().getLeft().cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="24-abstractdshandler"><a class="markdownIt-Anchor" href="#24-abstractdshandler"></a> 2.4 AbstractDSHandler</h3><p>下面定义实际的动态线程池处理方法，这里采用抽象类实现，将共用逻辑封装起来，方便扩展。</p><p>具有以下抽象方法：</p><ul><li><code>List&lt;T&gt; listTaskInfo()</code>：获取所有的任务信息。</li><li><code>void doProcess(T taskInfo)</code>：实现实际执行任务的业务逻辑。</li></ul><p>具有以下公共方法：</p><ul><li><code>void configureTasks(ScheduledTaskRegistrar taskRegistrar)</code>：创建 DSContainer 对象，并创建一个单线程的任务定时执行，调用 scheduleTask() 方法处理实际逻辑。</li><li><code>void scheduleTask()</code>：首先加载所有任务信息，然后基于 cron 表达式生成 TriggerTask 对象，调用 checkTask() 方法确认是否需要注册/取消任务。当达到执行时间时，调用 execute() 方法，执行任务逻辑。</li><li><code>void execute(final T taskInfo)</code>：获取信号量，成功后执行任务逻辑。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.SchedulingConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.config.ScheduledTaskRegistrar;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.config.TriggerTask;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.support.CronTrigger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象 Dynamic Schedule 实现，基于 SchedulingConfigurer 实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jitwxs</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年03月27日 16:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDSHandler</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">IDSTaskInfo</span>&gt; <span class="keyword">implements</span> <span class="title">SchedulingConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DSContainer&lt;T&gt; dsContainer;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String CLASS_NAME = getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有的任务信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;T&gt; <span class="title">listTaskInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 做具体的任务逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p/&gt; 该方法执行时位于跟 SpringBoot <span class="doctag">@Scheduled</span> 注解相同的线程池内。如果内部仍需要开子线程池执行，请务必同步等待子线程池执行完毕，否则可能会影响预期效果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doProcess</span><span class="params">(T taskInfo)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> </span>&#123;</span><br><span class="line">        dsContainer = <span class="keyword">new</span> DSContainer&lt;&gt;(taskRegistrar, CLASS_NAME);</span><br><span class="line">        <span class="comment">// 每隔 100ms 调度一次，用于读取所有任务</span></span><br><span class="line">        taskRegistrar.addFixedDelayTask(<span class="keyword">this</span>::scheduleTask, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调度任务，加载所有任务并注册</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CollectionUtils.emptyIfNull(listTaskInfo()).forEach(taskInfo -&gt;</span><br><span class="line">                dsContainer.checkTask(taskInfo, <span class="keyword">new</span> TriggerTask(() -&gt;</span><br><span class="line">                        <span class="keyword">this</span>.execute(taskInfo), triggerContext -&gt; <span class="keyword">new</span> CronTrigger(taskInfo.getCron()).nextExecutionTime(triggerContext)</span><br><span class="line">                ))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> T taskInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> taskId = taskInfo.getId();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Semaphore semaphore = dsContainer.getSemaphore(taskId);</span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(semaphore)) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;&#123;&#125; semaphore is null, taskId: &#123;&#125;&quot;</span>, CLASS_NAME, taskId);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (semaphore.tryAcquire(<span class="number">3</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    doProcess(taskInfo);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;&#123;&#125; doProcess error, taskId: &#123;&#125;&quot;</span>, CLASS_NAME, taskId, throwable);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;&#123;&#125; too many executor, taskId: &#123;&#125;&quot;</span>, CLASS_NAME, taskId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;&#123;&#125; interruptedException error, taskId: &#123;&#125;&quot;</span>, CLASS_NAME, taskId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;&#123;&#125; execute error, taskId: &#123;&#125;&quot;</span>, CLASS_NAME, taskId, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-快速测试"><a class="markdownIt-Anchor" href="#三-快速测试"></a> 三、快速测试</h2><p>至此就完成了动态任务的框架搭建，下面让我们来快速测试下。为了尽量减少其他技术带来的复杂度，本次测试不涉及数据库和真实的定时任务，完全采用模拟实现。</p><h3 id="31-模拟定时任务"><a class="markdownIt-Anchor" href="#31-模拟定时任务"></a> 3.1 模拟定时任务</h3><p>为了模拟一个定时任务，我定义了一个 <code>foo()</code> 方法，其中只输出一句话。后续我将通过定时调用该方法，来模拟定时任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125; Execute com.github.jitwxs.sample.ds.test.SchedulerTest#foo&quot;</span>, LocalTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="32-实现-idstaskinfo"><a class="markdownIt-Anchor" href="#32-实现-idstaskinfo"></a> 3.2 实现 IDSTaskInfo</h3><p>首先定义 IDSTaskInfo，我这里想通过反射来实现调用 <code>foo()</code> 方法，因此 <code>reference</code> 表示的是要调用方法的全路径。另外我实现了 <code>isChange()</code> 方法，只要 cron、isValid、reference 发生了变动，就认为该任务的配置发生了改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.github.jitwxs.sample.ds.config.IDSTaskInfo;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerTestTaskInfo</span> <span class="keyword">implements</span> <span class="title">IDSTaskInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cron;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isValid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String reference;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isChange</span><span class="params">(IDSTaskInfo oldTaskInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oldTaskInfo <span class="keyword">instanceof</span> SchedulerTestTaskInfo) &#123;</span><br><span class="line">            <span class="keyword">final</span> SchedulerTestTaskInfo obj = (SchedulerTestTaskInfo) oldTaskInfo;</span><br><span class="line">            <span class="keyword">return</span> !<span class="keyword">this</span>.cron.equals(obj.cron) || <span class="keyword">this</span>.isValid != obj.isValid || !<span class="keyword">this</span>.reference.equals(obj.getReference());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Not Support SchedulerTestTaskInfo type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="33-实现-abstractdshandler"><a class="markdownIt-Anchor" href="#33-实现-abstractdshandler"></a> 3.3 实现 AbstractDSHandler</h3><p>有几个需要关注的：</p><p>（1）<code>listTaskInfo()</code> 返回值我使用了 volatile 变量，便于我修改它，模拟任务信息数据的改变。</p><p>（2）<code>doProcess()</code> 方法中，读取到 reference 后，使用反射进行调用，模拟定时任务的执行。</p><p>（3）额外实现了 <code>ApplicationListener</code> 接口，当服务启动后，每隔一段时间修改下任务信息，模拟业务中调整配置。</p><ul><li>服务启动后，foo() 定时任务将每 10s 执行一次。</li><li>10s 后，将 foo() 定时任务执行周期从每 10s 执行调整为 1s 执行。</li><li>10s 后，关闭 foo() 定时任务执行。</li><li>10s 后，开启 foo() 定时任务执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.github.jitwxs.sample.ds.config.AbstractDSHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEvent;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jitwxs</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年03月27日 21:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerTestDSHandler</span> <span class="keyword">extends</span> <span class="title">AbstractDSHandler</span>&lt;<span class="title">SchedulerTestTaskInfo</span>&gt; <span class="keyword">implements</span> <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> List&lt;SchedulerTestTaskInfo&gt; taskInfoList = Collections.singletonList(</span><br><span class="line">            SchedulerTestTaskInfo.builder()</span><br><span class="line">                    .id(<span class="number">1</span>)</span><br><span class="line">                    .cron(<span class="string">&quot;0/10 * * * * ? &quot;</span>)</span><br><span class="line">                    .isValid(<span class="keyword">true</span>)</span><br><span class="line">                    .reference(<span class="string">&quot;com.github.jitwxs.sample.ds.test.SchedulerTest#foo&quot;</span>)</span><br><span class="line">                    .build()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;SchedulerTestTaskInfo&gt; <span class="title">listTaskInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> taskInfoList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doProcess</span><span class="params">(SchedulerTestTaskInfo taskInfo)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String reference = taskInfo.getReference();</span><br><span class="line">        <span class="keyword">final</span> String[] split = reference.split(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(split.length != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">final</span> Class&lt;?&gt; clazz = Class.forName(split[<span class="number">0</span>]);</span><br><span class="line">           <span class="keyword">final</span> Method method = clazz.getMethod(split[<span class="number">1</span>]);</span><br><span class="line">           method.invoke(clazz.newInstance());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent applicationEvent)</span> </span>&#123;</span><br><span class="line">        Executors.newScheduledThreadPool(<span class="number">1</span>).scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// setting 1 seconds execute</span></span><br><span class="line">            taskInfoList = Collections.singletonList(</span><br><span class="line">                    SchedulerTestTaskInfo.builder()</span><br><span class="line">                            .id(<span class="number">1</span>)</span><br><span class="line">                            .cron(<span class="string">&quot;0/1 * * * * ? &quot;</span>)</span><br><span class="line">                            .isValid(<span class="keyword">true</span>)</span><br><span class="line">                            .reference(<span class="string">&quot;com.github.jitwxs.sample.ds.test.SchedulerTest#foo&quot;</span>)</span><br><span class="line">                            .build()</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// setting not valid</span></span><br><span class="line">            taskInfoList = Collections.singletonList(</span><br><span class="line">                    SchedulerTestTaskInfo.builder()</span><br><span class="line">                            .id(<span class="number">1</span>)</span><br><span class="line">                            .cron(<span class="string">&quot;0/1 * * * * ? &quot;</span>)</span><br><span class="line">                            .isValid(<span class="keyword">false</span>)</span><br><span class="line">                            .reference(<span class="string">&quot;com.github.jitwxs.sample.ds.test.SchedulerTest#foo&quot;</span>)</span><br><span class="line">                            .build()</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// setting valid</span></span><br><span class="line">            taskInfoList = Collections.singletonList(</span><br><span class="line">                    SchedulerTestTaskInfo.builder()</span><br><span class="line">                            .id(<span class="number">1</span>)</span><br><span class="line">                            .cron(<span class="string">&quot;0/1 * * * * ? &quot;</span>)</span><br><span class="line">                            .isValid(<span class="keyword">true</span>)</span><br><span class="line">                            .reference(<span class="string">&quot;com.github.jitwxs.sample.ds.test.SchedulerTest#foo&quot;</span>)</span><br><span class="line">                            .build()</span><br><span class="line">            );</span><br><span class="line">        &#125;, <span class="number">12</span>, <span class="number">86400</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="34-运行程序"><a class="markdownIt-Anchor" href="#34-运行程序"></a> 3.4 运行程序</h3><p>整个应用包结构如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts//202103/20210328003410.png" alt="包结构" /></p><p>运行程序后，在控制台可以观测到如下输出：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts//202103/20210327232032.png" alt="运行结果" /></p><h2 id="四-后记"><a class="markdownIt-Anchor" href="#四-后记"></a> 四、后记</h2><p>以上完成了动态定时任务的介绍，你能够根据本篇文章，实现以下需求吗：</p><ul><li>本文基于 cron 表达式实现了频率控制，你能改用 fixedDelay 或 fixedRate 实现吗？</li><li>基于数据库/配置文件/配置中心，实现对服务中定时任务的动态频率调整和任务的启停。</li><li>开发一个数据表历史数据清理功能，能够动态配置要清理的表、清理的规则、清理的周期。</li><li>开发一个数据表异常数据告警功能，能够动态配置要扫描的表、告警的规则、扫描的周期。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-前言&quot;&gt;&lt;/a&gt; 一、前言&lt;/h2&gt;
&lt;p&gt;大家在日常工作中，一定使用过 Spring 的 &lt;code&gt;@Scheduled&lt;/code&gt; 注解吧，通过该注解可以非常方便的帮助</summary>
      
    
    
    
    <category term="Java Web" scheme="https://jitwxs.cn/categories/Java-Web/"/>
    
    <category term="SpringBoot" scheme="https://jitwxs.cn/categories/Java-Web/SpringBoot/"/>
    
    
    <category term="SchedulingConfigurer" scheme="https://jitwxs.cn/tags/SchedulingConfigurer/"/>
    
    <category term="定时任务" scheme="https://jitwxs.cn/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java 双亲委派机制</title>
    <link href="https://jitwxs.cn/9f878221.html"/>
    <id>https://jitwxs.cn/9f878221.html</id>
    <published>2021-03-14T03:26:34.000Z</published>
    <updated>2021-03-14T03:30:01.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-classloader"><a class="markdownIt-Anchor" href="#一-classloader"></a> 一、ClassLoader</h2><p>在介绍双亲委派机制之前，必须先要了解类加载器 <code>ClassLoader</code>，当 <code>.java</code> 文件经过编译生成 <code>.class</code> 文件后，需要通过 ClassLoader 将其加载入 JVM 中。</p><p>Java 中包括以下四类 ClassLoader：</p><ul><li>Bootstrap ClassLoader 启动类加载器【主要负责加载核心类库（<code>java,lang.*</code>）等】</li><li>Extension ClassLoader 扩展类加载器【主要负责加载 <code>jre/lib/ext</code> 目录下的扩展类库】</li><li>Application ClassLoader 应用程序类加载器【主要负责加载当前应用程序的类】</li><li>Custom ClassLoader 自定义类加载器</li></ul><h3 id="11-获取-classloader"><a class="markdownIt-Anchor" href="#11-获取-classloader"></a> 1.1 获取 ClassLoader</h3><p>通过 <code>java.lang.Class#getClassLoader</code> 方法就能够知道加载某个类的具体 ClassLoader，如下面代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.net.spi.nameservice.dns.DNSNameService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Object.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">        System.out.println(DNSNameService.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">        System.out.println(Foo.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">null</span></span><br><span class="line">sun.misc.Launcher$ExtClassLoader@7ef20235</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure><ul><li><code>Object.class</code> 是 <code>java.lang</code> 类，它的 ClassLoader 是 Bootstrap ClassLoader，但是由于 Bootstrap ClassLoader 采用 C++ 实现，因此其的输出结果为 null。</li><li><code>DNSNameService.class</code> 是 JRE 扩展包类，它的 ClassLoader 是 Extension ClassLoader。</li><li><code>Foo.class</code> 是我自定义的类，它的 ClassLoader 是 Application ClassLoader。</li></ul><h3 id="12-篡改-classloader"><a class="markdownIt-Anchor" href="#12-篡改-classloader"></a> 1.2 篡改 ClassLoader</h3><p>上一节提到 <code>Object.class</code> 是 <code>java.lang</code> 包提供的类。如果我自己也定义一个 <code>java.lang.Object</code> 类，能够编译通过吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Custom Object.class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行如上代码后会报错，原因就是因为 Java 的双亲委托机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误: 在类 java.lang.Object 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br></pre></td></tr></table></figure><h2 id="二-双亲委派机制"><a class="markdownIt-Anchor" href="#二-双亲委派机制"></a> 二、双亲委派机制</h2><h3 id="21-概念"><a class="markdownIt-Anchor" href="#21-概念"></a> 2.1 概念</h3><p>当 JVM 接收到需要加载类的请求时</p><p>（1）首先<strong>自下向上</strong>判断该类是否已经加载：</p><ul><li><p>首先判断 Custom ClassLoader 是否已经加载该类，如果没有加载，委派给自己的 parent classLoader --&gt; Extension ClassLoader。</p></li><li><p>判断 Application ClassLoader 是否已经加载该类，如果没有加载，委派给自己的 parent classLoader --&gt; Extension ClassLoader。</p></li><li><p>判断 Extension ClassLoader 是否已经加载该类，如果没有加载，委派给自己的 parent classLoader --&gt; Bootstrap ClassLoader。</p></li><li><p>判断 Bootstrap ClassLoader 是否已经加载该类。</p></li></ul><p>（2）如果所有 ClassLoader 都未加载，则<strong>自上向下</strong>加载该类：</p><ul><li>首先判断 Bootstrap ClassLoader 能否加载该类，如果不能加载，委派给自己的 child classLoader -&gt; Extension ClassLoader。</li><li>判断 Extension ClassLoader 能否加载该类，如果不能加载，委派给自己的 child classLoader -&gt; Extension Application 。</li><li>判断 Application ClassLoader 能否加载该类，如果不能加载，委派给自己的 child classLoader -&gt; Custom Application 。</li><li>判断 Custom Application 能否加载该类，如果不能加载，抛出 ClassNotFondException。</li></ul><p>下面两张流程图形象的描述了这种关系：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts//202103/20210314104028.png" alt="双亲委派机制-1" /></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts//202103/20210314105732.png" alt="双亲委派机制-2" /></p><p>这也就解释了为什么 1.2 节的代码运行会报错的原因。当运行 main 方法后，加载 <code>java.lang.Object.class</code> 的不是 Application ClassLoader 而是 Bootstrap ClassLoader，即实际被加载的是源码包的 Object.class，在那个类中是不存在 main 方法的。</p><h3 id="22-作用"><a class="markdownIt-Anchor" href="#22-作用"></a> 2.2 作用</h3><p><strong>（1）为什么要自下向上判断类是否已经加载？</strong></p><p>确保类只被加载一次，如果 parent ClassLoader 已经加载，那么 child ClassLoader 就无需加载。</p><p><strong>（2）为什么要自上向下加载类？</strong></p><p>确保 Java 核心类库不被 Application ClassLoader 或 Custom ClassLoader 所加载，保证安全。</p><h3 id="23-源码实现"><a class="markdownIt-Anchor" href="#23-源码实现"></a> 2.3 源码实现</h3><h4 id="231-加载-parent"><a class="markdownIt-Anchor" href="#231-加载-parent"></a> 2.3.1 加载 Parent</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ClassLoader: &quot;</span> + classLoader);</span><br><span class="line"></span><br><span class="line">            classLoader = classLoader.getParent();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(classLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ClassLoader: Bootstrap ClassLoader&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ClassLoader.getSystemClassLoader()</code> 获取默认委托的 ClassLoader，即最底层的。</li><li>通过 <code>getParent()</code> 获取上层 ClassLoader，当为 null 时表示当前已经是 Bootstrap ClassLoader。</li></ul><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">ClassLoader: sun.misc.Launcher$ExtClassLoader@2b193f2d</span><br><span class="line">ClassLoader: Bootstrap ClassLoader</span><br></pre></td></tr></table></figure><h4 id="232-classloaderloadclass"><a class="markdownIt-Anchor" href="#232-classloaderloadclass"></a> 2.3.2 ClassLoader#loadClass</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts//202103/20210314112545.png" alt="ClassLoader#loadClass" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-classloader&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-classloader&quot;&gt;&lt;/a&gt; 一、ClassLoader&lt;/h2&gt;
&lt;p&gt;在介绍双亲委派机制之前，必须先要了解类加载器 &lt;code&gt;ClassLoade</summary>
      
    
    
    
    <category term="Java" scheme="https://jitwxs.cn/categories/Java/"/>
    
    
    <category term="双亲委派" scheme="https://jitwxs.cn/tags/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>图解 | 你管这破玩意儿叫TCP？</title>
    <link href="https://jitwxs.cn/bef70352.html"/>
    <id>https://jitwxs.cn/bef70352.html</id>
    <published>2021-01-24T07:19:23.000Z</published>
    <updated>2021-01-24T08:06:31.010Z</updated>
    
    <content type="html"><![CDATA[<p><strong>你是一台电脑，你的名字叫 A</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124152910.png" alt="" /></p><p>经过<a href="/93fdc2b.html">《如果让你来设计网络》</a>这篇文章中的一番折腾，只要你知道另一位伙伴 B 的 IP 地址，且你们之间的网络是通的，无论多远，你都可以将一个数据包发送给你的伙伴 B</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124152911.png" alt="" /></p><p>这就是物理层、数据链路层、网络层这三层所做的事情。</p><p>站在第四层的你，就可以不要脸地利用下三层所做的铺垫，随心所欲地发送数据，而不必担心找不到对方了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124152912.gif" alt="" /></p><p>虽然你此时还什么都没干，但你还是给自己这一层起了个响亮的名字，叫做<strong>传输层</strong>。</p><p>你本以为自己所在的第四层万事大吉，啥事没有，但很快问题就接踵而至。</p><h2 id="问题来了"><a class="markdownIt-Anchor" href="#问题来了"></a> 问题来了</h2><p>前三层协议只能把数据包从一个主机搬到另外一台主机，但是，到了目的地以后，数据包具体交给哪个<strong>程序</strong>（进程）呢？</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124152913.png" alt="" /></p><p>所以，你需要把通信的进程区分开来，于是就给每个进程分配一个数字编号，你给它起了一个响亮的名字：<strong>端口号</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124152914.png" alt="" /></p><p>然后你在要发送的数据包上，增加了传输层的头部，<strong>源端口号</strong>与<strong>目标端口号</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124152915.png" alt="" /></p><p>OK，这样你将原本主机到主机的通信，升级为了<strong>进程和进程之间的通信</strong>。</p><p>你没有意识到，你不知不觉实现了 <strong>UDP 协议</strong>！</p><p>（当然 UDP 协议中不光有源端口和目标端口，还有数据包长度和校验值，我们暂且略过）</p><p>就这样，你用 UDP 协议无忧无虑地同 B 进行着通信，一直没发生什么问题。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153103.gif" alt="" /></p><p>但很快，你发现事情变得非常复杂…</p><h2 id="丢包问题"><a class="markdownIt-Anchor" href="#丢包问题"></a> 丢包问题</h2><p>由于网络的不可靠，数据包可能在半路丢失，而 A 和 B 却无法察觉。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153125.gif" alt="" /></p><p>对于丢包问题，只要解决两个事就好了。</p><p><strong>第一个，A 怎么知道包丢了？</strong></p><p>答案：让 B 告诉 A</p><p><strong>第二个，丢了的包怎么办？</strong></p><p>答案：重传</p><p>于是你设计了如下方案，A 每发一个包，都必须收到来自 B 的<strong>确认</strong>（ACK），再发下一个，否则在一定时间内没有收到确认，就<strong>重传</strong>这个包。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153148.gif" alt="" /></p><p>你管它叫<strong>停止等待协议</strong>。只要按照这个协议来，虽然 A 无法保证 B 一定能收到包，但 A 能够确认 B 是否收到了包，收不到就重试，尽最大努力让这个通信过程变得可靠，于是你们现在的通信过程又有了一个新的特征，<strong>可靠交付</strong>。</p><h2 id="效率问题"><a class="markdownIt-Anchor" href="#效率问题"></a> 效率问题</h2><p>停止等待虽然能解决问题，但是效率太低了，A 原本可以在发完第一个数据包之后立刻开始发第二个数据包，但由于停止等待协议，A 必须等数据包到达了 B ，且 B 的 ACK 包又回到了 A，才可以继续发第二个数据包，这效率慢得可不是一点两点。</p><p>于是你对这个过程进行了改进，采用<strong>流水线</strong>的方式，不再傻傻地等。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153149.gif" alt="" /></p><h2 id="顺序问题"><a class="markdownIt-Anchor" href="#顺序问题"></a> 顺序问题</h2><p>但是网路是复杂的、不可靠的。</p><p>有的时候 A 发出去的数据包，分别走了不同的路由到达 B，可能无法保证和发送数据包时一样的顺序。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153231.gif" alt="" /></p><p>在流水线中有多个数据包和ACK包在<strong>乱序流动</strong>，他们之间对应关系就乱掉了。</p><p>难道还回到停止等待协议？A 每收到一个包的确认（ACK）再发下一个包，那就根本不存在顺序问题。应该有更好的办法！</p><p>A 在发送的数据包中增加一个<strong>序号</strong>（seq），同时 B 要在 ACK 包上增加一个<strong>确认号</strong>（ack），这样不但解决了停止等待协议的效率问题，也通过这样标序号的方式解决了顺序问题。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153232.gif" alt="" /></p><p>而 B 这个确认号意味深长：比如 B 发了一个确认号为 ack = 3，它不仅仅表示 A 发送的序号为 2 的包收到了，还表示 2 之前的数据包都收到了。这种方式叫<strong>累计确认</strong>或<strong>累计应答</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153233.gif" alt="" /></p><p>注意，实际上 ack 的号是收到的最后一个数据包的序号 seq + 1，也就是告诉对方下一个应该发的序号是多少。但图中为了便于理解，ack 就表示收到的那个序号，不必纠结。</p><h2 id="流量问题"><a class="markdownIt-Anchor" href="#流量问题"></a> 流量问题</h2><p>有的时候，A 发送数据包的速度太快，而 B 的接收能力不够，但 B 却没有告知 A 这个情况。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153234.gif" alt="" /></p><p>怎么解决呢？</p><p>很简单，B 告诉 A 自己的接收能力，A 根据 B 的接收能力，相应控制自己的<strong>发送速率</strong>，就好了。</p><p>B 怎么告诉 A 呢？B 跟 A 说&quot;我很强&quot;这三个字么？那肯定不行，得有一个严谨的规范。</p><p>于是 B 决定，每次发送数据包给 A 时，顺带传过来一个值，叫<strong>窗口大小</strong>（win)，这个值就表示 B 的<strong>接收能力</strong>。同理，每次 A 给 B 发包时也带上自己的窗口大小，表示 A 的接收能力。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153235.gif" alt="" /></p><p>B 告诉了 A 自己的窗口大小值，A 怎么利用它去做 A 这边发包的流量控制呢？</p><p>很简单，假如 B 给 A 传过来的窗口大小 win = 5，那 A 根据这个值，把自己要发送的数据分成这么几类。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153236.png" alt="" /></p><p>图片过于清晰，就不再文字解释了。</p><p>当 A 不断发送数据包时，<strong>已发送的最后一个序号</strong>就往右移动，直到碰到了窗口的上边界，此时 A 就无法继续发包，达到了流量控制。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153236.gif" alt="" /></p><p>但是当 A 不断发包的同时，A 也会收到来自 B 的确认包，此时<strong>整个窗口</strong>会往右移动，因此上边界也往右移动，A 就能发更多的数据包了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153237.gif" alt="" /></p><p>以上都是在窗口大小不变的情况下，而 B 在发给 A 的 ACK 包中，每一个都可以<strong>重新设置</strong>一个新的窗口大小，如果 A 收到了一个新的窗口大小值，A 会随之调整。</p><p>如果 A 收到了比原窗口值更大的窗口大小，比如 win = 6，则 A 会直接将窗口上边界向右移动 1 个单位。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153238.gif" alt="" /></p><p>如果 A 收到了比原窗口值小的窗口大小，比如 win = 4，则 A 暂时不会改变窗口大小，更不会将窗口上边界向左移动，而是等着 ACK 的到来，不断将左边界向右移动，直到窗口大小值收缩到新大小为止。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153239.gif" alt="" /></p><p>OK，终于将流量控制问题解决得差不多了，你看着上面一个个小动图，给这个窗口起了一个更生动的名字，<strong>滑动窗口</strong>。</p><h2 id="拥塞问题"><a class="markdownIt-Anchor" href="#拥塞问题"></a> 拥塞问题</h2><p>但有的时候，不是 B 的接受能力不够，而是网络不太好，造成了<strong>网络拥塞</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153518.gif" alt="" /></p><p>拥塞控制与流量控制有些像，但流量控制是受 B 的接收能力影响，而拥塞控制是受<strong>网络环境</strong>的影响。</p><p>拥塞控制的解决办法依然是通过设置一定的窗口大小，只不过，流量控制的窗口大小是 B 直接告诉 A 的，而拥塞控制的窗口大小按理说就应该是网络环境主动告诉 A。</p><p>但网络环境怎么可能主动告诉 A 呢？只能 A 单方面通过<strong>试探</strong>，不断感知网络环境的好坏，进而确定自己的拥塞窗口的大小。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153519.gif" alt="" /></p><p>拥塞窗口大小的计算有很多复杂的算法，就不在本文中展开了，假如<strong>拥塞窗口的大小为  cwnd</strong>，上一部分流量控制的<strong>滑动窗口的大小为 rwnd</strong>，那么窗口的右边界受这两个值共同的影响，需要取它俩的最小值。</p><p><strong>窗口大小 = min(cwnd, rwnd)</strong></p><p>含义很容易理解，当 B 的接受能力比较差时，即使网络非常通畅，A 也需要根据 B 的接收能力限制自己的发送窗口。当网络环境比较差时，即使 B 有很强的接收能力，A 也要根据网络的拥塞情况来限制自己的发送窗口。正所谓受其<strong>短板</strong>的影响嘛~</p><h2 id="连接问题"><a class="markdownIt-Anchor" href="#连接问题"></a> 连接问题</h2><p>有的时候，B 主机的相应进程还没有准备好或是挂掉了，A 就开始发送数据包，导致了浪费。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153638.gif" alt="" /></p><p>这个问题在于，A 在跟 B 通信之前，没有事先确认 B 是否已经准备好，就开始发了一连串的信息。就好比你和另一个人打电话，你还没有&quot;喂&quot;一下确认对方有没有在听，你就巴拉巴拉说了一堆。</p><p>这个问题该怎么解决呢？</p><p>地球人都知道，<strong>三次握手</strong>嘛！</p><p>A：我准备好了(SYN)</p><p>B：我知道了(ACK)，我也准备好了(SYN)</p><p>A：我知道了(ACK)</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153639.gif" alt="" /></p><p>A 与 B 各自在内存中维护着自己的状态变量，三次握手之后，双方的状态都变成了<strong>连接已建立</strong>（ESTABLISHED）。</p><p>虽然就只是发了三次数据包，并且在各自的内存中维护了状态变量，但这么说总觉得太 low，你看这个过程相当于双方建立连接的过程，于是你灵机一动，就叫它<strong>面向连接</strong>吧。</p><p>注意：这个连接是虚拟的，是由 A 和 B 这两个终端共同维护的，在网络中的设备根本就不知道连接这回事儿！</p><p>但凡事有始就有终，有了建立连接的过程，就要考虑释放连接的过程，又是地球人都知道，<strong>四次挥手</strong>嘛！</p><p>A：再见，我要关闭了(FIN)</p><p>B：我知道了(ACK)</p><p>给 B 一段时间把自己的事情处理完…</p><p>B：再见，我要关闭了(FIN)</p><p>A：我知道了(ACK)</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153707.gif" alt="" /></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>以上讲述的，就是 TCP 协议的核心思想，上面过程中需要传输的信息，就体现在 TCP 协议的头部，这里放上最常见的 TCP 协议头解读的图。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153708.png" alt="" /></p><p>不知道你现在再看下面这句话，是否能理解：</p><p><strong>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议</strong></p><p>面向连接、可靠，这两个词通过上面的讲述很容易理解，那什么叫做基于字节流呢？</p><p>很简单，TCP 在建立连接时，需要告诉对方 MSS（最大报文段大小）。</p><p>也就是说，如果要发送的数据很大，在 TCP 层是需要按照 MSS 来切割成一个个的 <strong>TCP 报文段</strong> 的。</p><p>切割的时候我才不管你原来的数据表示什么意思，需要在哪里断句啥的，我就把它当成一串毫无意义的字节，在我想要切割的地方咔嚓就来一刀，标上序号，只要接收方再根据这个序号拼成最终想要的完整数据就行了。</p><p>在我 TCP 传输这里，我就把它当做一个个的<strong>字节</strong>，也就是基于字节流的含义了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124153709.jpg" alt="" /></p><p>最后留给大家一个作业，模拟 A 与 B 建立一个 TCP 连接。</p><p><strong>第一题</strong>：A 给 B 发送 “aaa” ，然后 B 给 A 回复一个简单的字符串 “success”，并将此过程抓包。</p><p><strong>第二题</strong>：A 给 B 发送 “aaaaaa … a” 超过最大报文段大小，然后 B 给 A 回复一个简单的字符串 “success”，并将此过程抓包。</p><p>下面是我抓的包（第二题）</p><p><strong>三次握手阶段</strong></p><p>A -&gt; B [SYN] Seq=0 Win=64240 Len=0</p><p>​            MSS=1460 WS=256</p><p>B - &gt;A [SYN, ACK] Seq=0 Ack=1 Win=29200 Len=0</p><p>​            MSS=1424 WS=512</p><p>A -&gt; B [ACK] Seq=1 Ack=1 Win=132352 Len=0</p><p><strong>数据发送阶段</strong></p><p>A -&gt; B [ACK] Seq=1 Ack=1 Win=132352 Len=1424</p><p>A -&gt; B [ACK] Seq=1425 Ack=1 Win=132352 Len=1424</p><p>A -&gt; B [PSH, ACK] Seq=2849 Ack=1 Win=132352 Len=1247</p><p>B -&gt; A [ACK] Seq=1 Ack=1425 Win=32256 Len=0</p><p>B -&gt; A [ACK] Seq=1 Ack=2849 Win=35328 Len=0</p><p>B -&gt; A [ACK] Seq=1 Ack=4096 Win=37888 Len=0</p><p>B -&gt; A [PSH, ACK] Seq=1 Ack=4096 Win=37888 Len=7</p><p><strong>四次挥手阶段</strong></p><p>B -&gt; A [FIN, ACK] Seq=8 Ack=4096 Win=37888 Len=0</p><p>A -&gt; B [ACK] Seq=4096 Ack=9 Win=132352 Len=0</p><p>A -&gt; B [FIN, ACK] Seq=4096 Ack=9 Win=132352 Len=0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;你是一台电脑，你的名字叫 A&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-lazy-src=&quot;https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/2021</summary>
      
    
    
    
    <category term="网络" scheme="https://jitwxs.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP" scheme="https://jitwxs.cn/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>图解 | 你管这破玩意叫线程池？</title>
    <link href="https://jitwxs.cn/c376af5e.html"/>
    <id>https://jitwxs.cn/c376af5e.html</id>
    <published>2021-01-23T11:23:54.000Z</published>
    <updated>2021-01-24T08:00:06.881Z</updated>
    
    <content type="html"><![CDATA[<p>小宇：闪客，我最近看到线程池，被里边乱七八槽的参数给搞晕了，你能不能给我讲讲呀？</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124151222.gif" alt="" /></p><p>闪客：没问题，这个我擅长，咱们从一个最简单的情况开始，假设有一段代码，你希望异步执行它，是不是要写出这样的代码？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(r).start();</span><br></pre></td></tr></table></figure><p>小宇：嗯嗯，最简单的写法似乎就是这样呢。</p><p>闪客：这种写法当然可以完成功能，可是你这样写，老王这样写，老张也这样写，程序中到处都是这样创建线程的方法，能不能写一个统一的工具类让大家调用呢？</p><p>小宇：可以的，感觉有一个统一的工具类，更优雅一些。</p><p>闪客：那如果让你来设计这个工具类，你会怎么写呢？我先给你定一个接口，你来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小宇：emmm，我可能先定义几个成员变量，比如核心线程数、最大线程数 …反正就是那些乱七八糟的参数。</p><p>闪客：STOP！小宇呀，你现在深受面试手册的毒害，你先把这些全部的概念忘掉，就说让你写一个最简单的工具类，第一反应，你会怎么写？</p><h2 id="第一版"><a class="markdownIt-Anchor" href="#第一版"></a> 第一版</h2><p>小宇：那我可能会这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新线程：直接创建一个新线程运行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlashExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闪客：嗯嗯很好，你的思路非常棒。</p><p>小宇：啊，我这个会不会太 low 了呀，我还以为你会骂我呢。</p><p>怎么会， Doug Lea 大神在 JDK 源码注释中给出的就是这样的例子，这是最根本的功能。你在这个基础上，尝试着优化一下？</p><h2 id="第二版"><a class="markdownIt-Anchor" href="#第二版"></a> 第二版</h2><p>小宇：还能怎么优化呢？这不已经用一个工具类实现了异步执行了嘛！</p><p>闪客：我问你一个问题，假如有 10000 个人都调用这个工具类提交任务，那就会创建 10000 个线程来执行，这肯定不合适吧！能不能控制一下线程的数量呢？</p><p>小宇：这不难，我可以把这个任务 r 丢到一个 tasks 队列中，然后只启动一个线程，就叫它 <strong>Worker</strong> 线程吧，不断从 tasks 队列中取任务，执行任务。这样无论调用者调用多少次，永远就只有一个 Worker 线程在运行，像这样。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124151223.gif" alt="" /></p><p>闪客：太棒了，这个设计有了三个重大的意义：</p><ol><li><p>控制了线程数量。</p></li><li><p>队列不但起到了缓冲的作用，还将任务的提交与执行解耦了。</p></li><li><p>最重要的一点是，解决了每次重复创建和销毁线程带来的系统开销。</p></li></ol><p>小宇：哇真的么，这么小的改动有这么多意义呀。</p><p>闪客：那当然，不过只有一个后台的工作线程 Worker 会不会少了点？还有如果这个 tasks 队列满了怎么办呢？</p><h2 id="第三版"><a class="markdownIt-Anchor" href="#第三版"></a> 第三版</h2><p>小宇：哦，的确，只有一个线程在某些场景下是很吃力的，那我把 Worker 线程的数量增加？</p><p>闪客：没错，Worker 线程的数量要增加，但是具体数量要让使用者决定，调用时传入，就叫核心线程数 <strong>corePoolSize</strong> 吧。</p><p>小宇：好的，那我这样设计。</p><ol><li><p>初始化线程池时，直接启动 corePoolSize 个工作线程 Worker 先跑着。</p></li><li><p>这些 Worker 就是死循环从队列里取任务然后执行。</p></li><li><p>execute 方法仍然是直接把任务放到队列，但队列满了之后直接抛弃</p></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124151224.gif" alt="" /></p><p>闪客：太完美了，奖励你一块费列罗吧。</p><p>小宇：哈哈谢谢，那我先吃一会儿哈。</p><p>闪客：好，你边吃我边说。现在我们已经实现了一个至少不那么丑陋的线程池了，但还有几处小瑕疵，比如初始化的时候，就创建了一堆 Worker 线程在那空跑着，假如此时并没有异步任务提交过来执行，这就有点浪费了。</p><p>小宇：哦好像是诶！</p><p>闪客：还有，你这队列一满，就直接把新任务丢弃了，这样有些粗暴，能不能让调用者自己决定该怎么处理呢？</p><p>小宇：哎呀，想不到我这么温柔的妹纸居然写出了这么粗暴的代码。</p><p>闪客：额，你先把费列罗咽下去吧。</p><h2 id="第四版"><a class="markdownIt-Anchor" href="#第四版"></a> 第四版</h2><p>小宇：我吃完了，现在脑子有点不够用了，得先消化消化食物，要不你帮我分析分析吧。</p><p>闪客：好的，现在我们做出如下改进。</p><p><strong>1. 按需创建Worker</strong>：刚初始化线程池时，不再立刻创建 corePoolSize 个工作线程，而是等待调用者不断提交任务的过程中，逐渐把工作线程 Worker 创建出来，等数量达到 corePoolSize 时就停止，把任务直接丢到队列里。那就必然要用一个属性记录已经创建出来的工作线程数量，就叫 <strong>workCount</strong> 吧。</p><p><strong>2. 加拒绝策略</strong>：实现上就是增加一个入参，类型是一个接口 <strong>RejectedExecutionHandler</strong>，由调用者决定实现类，以便在任务提交失败后执行 rejectedExecution 方法。</p><p><strong>3. 增加线程工厂</strong>：实现上就是增加一个入参，类型是一个接口 <strong>ThreadFactory</strong>，增加工作线程时不再直接 new 线程，而是调用这个由调用者传入的 ThreadFactory 实现类的 newThread 方法。</p><p>就像下面这样。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124151226.gif" alt="" /></p><p>小宇：哇，还是你厉害，这一版应该很完美了吧？</p><p>闪客：不不不，离完美还差得很远，接下来的改进，由你来想吧，我这里可以给你一个提示：<strong>弹性思维</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124151225.gif" alt="" /></p><h2 id="第五版"><a class="markdownIt-Anchor" href="#第五版"></a> 第五版</h2><p>小宇：弹性思维？哈哈闪客你这术语说的真是越来越不像人话了</p><p>闪客：咳咳</p><p>小宇：哦，我是说你肯定是指我这个代码写的没有弹性，对吧？可是弹性是指什么呢？</p><p>闪客：简单说，在这个场景里，弹性就是在任务提交比较频繁，和任务提交非常不频繁这两种情况下，你这个代码是否有问题？</p><p>小宇：emmm 让我想想，我这个线程池，当提交任务的量突增时，工作线程和队列都被占满了，就只能走拒绝策略，其实就是被丢弃掉</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124151227.gif" alt="" /></p><p>闪客：是的</p><p>小宇：这样的确是太硬了，诶不过我想了下，调用方可以通过设置很大的核心线程数 corePoolSize 来解决这个问题呀。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124151228.gif" alt="" /></p><p>闪客：的确是可以，但一般场景下 QPS 高峰期都很短，而为了这个很短暂的高峰，设置很大的核心线程数，简直太浪费资源了，你看上面的图不觉得眼晕么？</p><p>小宇：是呀，那怎么办呢，太大了也不行，太小了也不行。</p><p>闪客：我们可以发明一个新的属性，叫最大线程数 <strong>maximumPoolSize</strong>。当核心线程数和队列都满了时，新提交的任务仍然可以通过创建新的工作线程（叫它<strong>非核心线程</strong>），直到工作线程数达到 maximumPoolSize 为止，这样就可以缓解一时的高峰期了，而用户也不用设置过大的核心线程数。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124151229.png" alt="" /></p><p>小宇：哦好像有点感觉了，可是具体怎么操作呢？</p><p>闪客：想象力不行呀小宇，那你看下面的演示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124151230.gif" alt="" /></p><ol><li><p>开始的时候和上一版一样，当 workCount &lt; corePoolSize 时，通过创建新的 Worker 来执行任务。</p></li><li><p>当 workCount &gt;= corePoolSize 就停止创建新线程，把任务直接丢到队列里。</p></li><li><p>但当队列已满且仍然 workCount &lt; maximumPoolSize 时，不再直接走拒绝策略，而是创建非核心线程，直到 workCount = maximumPoolSize，再走拒绝策略。</p></li></ol><p>小宇：哎呀，我怎么没想到，这样 corePoolSize 就负责平时大多数情况所需要的工作线程数，而 maximumPoolSize 就负责在高峰期临时扩充工作线程数。</p><p>闪客：没错，高峰时期的弹性搞定了，那自然就还要考虑低谷时期。当长时间没有任务提交时，核心线程与非核心线程都一直空跑着，浪费资源。我们可以给<strong>非核心线程</strong>设定一个超时时间 <strong>keepAliveTime</strong>，当这么长时间没能从队列里获取任务时，就不再等了，销毁线程。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124151231.gif" alt="" /></p><p>小宇：嗯，这回咱们的线程池在 QPS 高峰时可以临时扩容，QPS 低谷时又可以及时回收线程（非核心线程）而不至于浪费资源，真的显得十分 Q 弹呢。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124151225.gif" alt="" /></p><p>闪客：是呀是呀。诶不对，怎么又变成我说了，不是说这一版你来思考么？</p><p>小宇：我也想啊，但你这一讲技术就自说自话的毛病老是不改，我有啥办法。</p><p>闪客：额抱歉抱歉，那接下来你总结一下我们的线程池吧</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>小宇：嗯好的，首先它的构造方法是这个样子滴</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FlashExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">        ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        RejectedExecutionHandler handler)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... <span class="comment">// 省略一些参数校验</span></span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些参数分别是</p><p><strong>int corePoolSize</strong>：核心线程数</p><p><strong>int maximumPoolSize</strong>：最大线程数</p><p><strong>long keepAliveTime</strong>：非核心线程的空闲时间</p><p><strong>TimeUnit unit</strong>：空闲时间的单位</p><p><strong>BlockingQueue<Runnable> workQueue</strong>：任务队列（线程安全的阻塞队列）</p><p><strong>ThreadFactory threadFactory</strong>：线程工厂</p><p><strong>RejectedExecutionHandler handler</strong>：拒绝策略</p><p>整个任务的提交流程是</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124151232.png" alt="" /></p><p>闪客：不错不错，这可是你自己总结的哟，现在还用我给你讲什么是线程池了么？</p><p>小宇：啊天呢，我才发现这似乎就是我一直弄不清楚的线程池的参数和原理呢！</p><p>闪客：没错，而且最后一版代码的构造方法，就是 Java 面试常考的 <strong>ThreadPoolExecutor</strong> 最长的那个构造方法，参数名都没变。</p><p>小宇：哇，太赞了！我都忘了一开始我想干嘛了，嘻嘻。</p><p>闪客：哈哈，不知不觉学到了技术才爽呢，对吧？晚饭时间快到了，要不要一块去吃山西面馆呀？</p><p>小宇：哦，那家店餐桌的颜色我不太喜欢，下次吧。</p><p>闪客：哦好吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;小宇：闪客，我最近看到线程池，被里边乱七八槽的参数给搞晕了，你能不能给我讲讲呀？&lt;/p&gt;
&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-lazy-src=&quot;https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/p</summary>
      
    
    
    
    <category term="Java" scheme="https://jitwxs.cn/categories/Java/"/>
    
    <category term="并发编程" scheme="https://jitwxs.cn/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="线程池" scheme="https://jitwxs.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>如果让你来设计网络</title>
    <link href="https://jitwxs.cn/93fdc2b.html"/>
    <id>https://jitwxs.cn/93fdc2b.html</id>
    <published>2021-01-23T07:39:03.000Z</published>
    <updated>2021-01-24T08:17:54.222Z</updated>
    
    <content type="html"><![CDATA[<p><strong>你是一台电脑，你的名字叫 A</strong></p><p>很久很久之前，你不与任何其他电脑相连接，孤苦伶仃。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124152910.png" alt="" /></p><p>直到有一天，你希望与另一台电脑 B 建立通信，于是你们各开了一个网口，用一根<strong>网线</strong>连接了起来。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124154503.png" alt="" /></p><p>用一根网线连接起来怎么就能&quot;通信&quot;了呢？我可以给你讲 IO、讲中断、讲缓冲区，但这不是研究网络时该关心的问题。</p><p>如果你纠结，要么去研究一下操作系统是如何处理网络 IO 的，要么去研究一下包是如何被网卡转换成电信号发送出去的，要么就仅仅把它当做电脑里有个小人在<strong>开枪</strong>吧~</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124154504.gif" alt="" /></p><p>反正，你们就是连起来了，并且可以通信。</p><h2 id="第一层"><a class="markdownIt-Anchor" href="#第一层"></a> 第一层</h2><p>有一天，一个新伙伴 C 加入了，但聪明的你们很快发现，可以每个人开<strong>两个网口</strong>，用一共<strong>三根网线</strong>，彼此相连。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124154505.png" alt="" /></p><p>随着越来越多的人加入，你发现身上开的网口实在太多了，而且网线密密麻麻，混乱不堪。（而实际上一台电脑根本开不了这么多网口，所以这种连线只在理论上可行，所以连不上的我就用红色虚线表示了，就是这么严谨哈哈~）</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124154506.png" alt="" /></p><p>于是你们发明了一个中间设备，你们将网线都插到这个设备上，由这个设备做转发，就可以彼此之间通信了，本质上和原来一样，只不过网口的数量和网线的数量减少了，不再那么混乱。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124154507.png" alt="" /></p><p>你给它取名叫<strong>集线器</strong>，它仅仅是无脑将电信号<strong>转发到所有出口（广播）</strong>，不做任何处理，你觉得它是没有智商的，因此把人家定性在了<strong>物理层</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124154508.gif" alt="" /></p><p>由于转发到了所有出口，那 BCDE 四台机器怎么知道数据包是不是发给自己的呢？</p><p>首先，你要给所有的连接到集线器的设备，都起个名字。原来你们叫 ABCD，但现在需要一个更专业的，<strong>全局唯一</strong>的名字作为标识，你把这个更高端的名字称为 <strong>MAC 地址</strong>。</p><p>你的 MAC 地址是 aa-aa-aa-aa-aa-aa，你的伙伴 b 的 MAC 地址是 bb-bb-bb-bb-bb-bb，以此类推，不重复就好。</p><p>这样，A 在发送数据包给 B 时，只要在头部拼接一个这样结构的数据，就可以了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124154509.png" alt="" /></p><p>B 在收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包的确是发给自己的，于是便<strong>收下</strong>。</p><p>其他的 CDE 收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包并不是发给自己的，于是便<strong>丢弃</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124154651.gif" alt="" /></p><p>虽然集线器使整个布局干净不少，但原来我只要发给电脑 B 的消息，现在却要发给连接到集线器中的所有电脑，这样既不安全，又不节省网络资源。</p><h2 id="第二层"><a class="markdownIt-Anchor" href="#第二层"></a> 第二层</h2><p>如果把这个集线器弄得更智能一些，<strong>只发给目标 MAC 地址指向的那台电脑</strong>，就好了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124154652.gif" alt="" /></p><p>虽然只比集线器多了这一点点区别，但看起来似乎有智能了，你把这东西叫做<strong>交换机</strong>。也正因为这一点点智能，你把它放在了另一个层级，<strong>数据链路层</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124154653.png" alt="" /></p><p>如上图所示，你是这样设计的。</p><p>交换机内部维护一张 <strong>MAC 地址表</strong>，记录着每一个 MAC 地址的设备，连接在其哪一个端口上。</p><table><thead><tr><th>MAC 地址</th><th>端口</th></tr></thead><tbody><tr><td>bb-bb-bb-bb-bb-bb</td><td>1</td></tr><tr><td>cc-cc-cc-cc-cc-cc</td><td>3</td></tr><tr><td>aa-aa-aa-aa-aa-aa</td><td>4</td></tr><tr><td>dd-dd-dd-dd-dd-dd</td><td>5</td></tr></tbody></table><p>假如你仍然要发给 B 一个数据包，构造了如下的数据结构从网口出去。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124154509.png" alt="" /></p><p>到达交换机时，交换机内部通过自己维护的 MAC 地址表，发现<strong>目标机器 B 的 MAC 地址 bb-bb-bb-bb-bb-bb 映射到了端口 1 上</strong>，于是把数据从 1 号端口发给了 B，完事~</p><p>你给这个通过这样传输方式而组成的小范围的网络，叫做<strong>以太网</strong>。</p><p>当然最开始的时候，MAC 地址表是空的，是怎么逐步建立起来的呢？</p><p>假如在 MAC 地址表为空是，你给 B 发送了如下数据</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124154509.png" alt="" /></p><p>由于这个包从端口 4 进入的交换机，所以此时交换机就可以在 MAC地址表记录第一条数据：</p><p><strong>MAC：aa-aa-aa-aa-aa-aa-aa<br />端口：4</strong></p><p>交换机看目标 MAC 地址（bb-bb-bb-bb-bb-bb）在地址表中并没有映射关系，于是将此包发给了<strong>所有端口</strong>，也即发给了所有机器。</p><p>之后，只有机器 B 收到了确实是发给自己的包，于是做出了<strong>响应</strong>，响应数据从端口 1 进入交换机，于是交换机此时在地址表中更新了第二条数据：</p><p><strong>MAC：bb-bb-bb-bb-bb-bb<br />端口：1</strong></p><p>过程如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124154834.gif" alt="" /></p><p>经过该网络中的机器不断地通信，交换机最终将 MAC 地址表建立完毕~</p><hr /><p>随着机器数量越多，交换机的端口也不够了，但聪明的你发现，只要将多个交换机连接起来，这个问题就轻而易举搞定~</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124154835.png" alt="" /></p><p>你完全不需要设计额外的东西，只需要按照之前的设计和规矩来，按照上述的接线方式即可完成所有电脑的互联，所以交换机设计的这种规则，真的很巧妙。你想想看为什么（比如 A 要发数据给 F）。</p><p>但是你要注意，上面那根红色的线，最终在 MAC 地址表中可不是一条记录呀，而是要把 EFGH 这四台机器与该端口（端口6）的映射全部记录在表中。</p><p>最终，<strong>两个交换机将分别记录 A ~ H 所有机器的映射记录</strong>。</p><p><strong>左边的交换机</strong></p><table><thead><tr><th>MAC 地址</th><th>端口</th></tr></thead><tbody><tr><td>bb-bb-bb-bb-bb-bb</td><td>1</td></tr><tr><td>cc-cc-cc-cc-cc-cc</td><td>3</td></tr><tr><td>aa-aa-aa-aa-aa-aa</td><td>4</td></tr><tr><td>dd-dd-dd-dd-dd-dd</td><td>5</td></tr><tr><td>ee-ee-ee-ee-ee-ee</td><td>6</td></tr><tr><td>ff-ff-ff-ff-ff-ff</td><td>6</td></tr><tr><td>gg-gg-gg-gg-gg-gg</td><td>6</td></tr><tr><td>hh-hh-hh-hh-hh-hh</td><td>6</td></tr></tbody></table><p><strong>右边的交换机</strong></p><table><thead><tr><th>MAC 地址</th><th>端口</th></tr></thead><tbody><tr><td>bb-bb-bb-bb-bb-bb</td><td>1</td></tr><tr><td>cc-cc-cc-cc-cc-cc</td><td>1</td></tr><tr><td>aa-aa-aa-aa-aa-aa</td><td>1</td></tr><tr><td>dd-dd-dd-dd-dd-dd</td><td>1</td></tr><tr><td>ee-ee-ee-ee-ee-ee</td><td>2</td></tr><tr><td>ff-ff-ff-ff-ff-ff</td><td>3</td></tr><tr><td>gg-gg-gg-gg-gg-gg</td><td>4</td></tr><tr><td>hh-hh-hh-hh-hh-hh</td><td>6</td></tr></tbody></table><p>这在只有 8 台电脑的时候还好，甚至在只有几百台电脑的时候，都还好，所以这种交换机的设计方式，已经足足支撑一阵子了。</p><p>但很遗憾，人是贪婪的动物，很快，电脑的数量就发展到几千、几万、几十万。</p><h2 id="第三层"><a class="markdownIt-Anchor" href="#第三层"></a> 第三层</h2><p>交换机已经无法记录如此庞大的映射关系了。</p><p>此时你动了歪脑筋，你发现了问题的根本在于，连出去的那根红色的网线，后面不知道有多少个设备不断地连接进来，从而使得地址表越来越大。</p><p>那我可不可以让那根红色的网线，接入一个<strong>新的设备</strong>，这个设备就跟电脑一样有自己独立的 MAC 地址，而且同时还能帮我把数据包做一次<strong>转发</strong>呢？</p><p>这个设备就是<strong>路由器</strong>，它的功能就是，作为一台独立的拥有 MAC 地址的设备，并且可以帮我把数据包做一次转发**，<strong>你把它定在了</strong>网络层**。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124154837.png" alt="" /></p><p>注意，路由器的每一个端口，都有独立的 MAC 地址</p><p>好了，现在交换机的 MAC 地址表中，只需要多出一条 MAC 地址 ABAB 与其端口的映射关系，就可以成功把数据包转交给路由器了，这条搞定。</p><p>那如何做到，把发送给 C 和 D，甚至是把发送给 DEFGH… 的数据包，统统先发送给路由器呢？</p><p>不难想到这样一个点子，假如电脑 C 和 D 的 MAC 地址拥有共同的前缀，比如分别是</p><p><strong>C 的 MAC 地址：FFFF-FFFF-CCCC</strong></p><p><strong>D 的 MAC 地址：FFFF-FFFF-DDDD</strong></p><p>那我们就可以说，将目标 MAC 地址为 <strong>FFFF-FFFF-？开头的</strong>，统统先发送给路由器。</p><p>这样是否可行呢？答案是否定的。</p><p>我们先从现实中 MAC 地址的结构入手，MAC地址也叫物理地址、硬件地址，长度为 48 位，一般这样来表示</p><p><strong>00-16-EA-AE-3C-40</strong></p><p>它是由网络设备制造商生产时烧录在网卡的EPROM（一种闪存芯片，通常可以通过程序擦写）。其中**前 24 位（00-16-EA）代表网络硬件制造商的编号****，后 24 位（AE-3C-40）是该厂家自己分配的，一般表示系列号。**只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。形象地说，MAC地址就如同身份证上的身份证号码，具有唯一性。</p><p>那如果你希望向上面那样表示将目标 MAC 地址为 <strong>FFFF-FFFF-？开头的</strong>，统一从路由器出去发给某一群设备（后面会提到这其实是子网的概念），那你就需要要求某一子网下统统买一个厂商制造的设备，要么你就需要要求厂商在生产网络设备烧录 MAC 地址时，提前按照你规划好的子网结构来定 MAC 地址，并且日后这个网络的结构都不能轻易改变。</p><p>这显然是不现实的。</p><p>于是你发明了一个新的地址，给每一台机器一个 32 位的编号，如：</p><p><strong>11000000101010000000000000000001</strong></p><p>你觉得有些不清晰，于是把它分成四个部分，中间用点相连。</p><p><strong>11000000.10101000.00000000.00000001</strong></p><p>你还觉得不清晰，于是把它转换成 10 进制。</p><p><strong>192.168.0.1</strong></p><p>最后你给了这个地址一个响亮的名字，<strong>IP 地址</strong>。现在每一台电脑，同时有自己的 MAC 地址，又有自己的 IP 地址，只不过 IP 地址是<strong>软件层面</strong>上的，可以随时修改，MAC 地址一般是无法修改的。</p><p>这样一个可以随时修改的 IP 地址，就可以根据你规划的网络拓扑结构，来调整了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124154838.png" alt="" /></p><p>如上图所示，假如我想要发送数据包给 ABCD 其中一台设备，不论哪一台，我都可以这样描述，<strong>“将 IP 地址为 192.168.0 开头的全部发送给到路由器，之后再怎么转发，交给它！”</strong>，巧妙吧。</p><p>那交给路由器之后，路由器又是怎么把数据包准确转发给指定设备的呢？</p><p>别急我们慢慢来。</p><p>我们先给上面的组网方式中的每一台设备，加上自己的 IP 地址</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124154839.png" alt="" /></p><p>现在两个设备之间传输，除了加上数据链路层的头部之外，还要再增加一个网络层的头部。</p><p>假如 A 给 B 发送数据，由于它们直接连着交换机，所以 A 直接发出如下数据包即可，其实网络层没有体现出作用。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124155108.png" alt="" /></p><p>但假如 A 给 C 发送数据，A 就需要先转交给路由器，然后再由路由器转交给 C。由于最底层的传输仍然需要依赖以太网，所以数据包是分成两段的。</p><p>A ~ 路由器这段的包如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124155109.png" alt="" /></p><p>路由器到 C 这段的包如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124155105.png" alt="" /></p><p>好了，上面说的两种情况（A-&gt;B，A-&gt;C），相信细心的读者应该会有不少疑问，下面我们一个个来展开。</p><h2 id="a-给-c-发数据包怎么知道是否要通过路由器转发呢"><a class="markdownIt-Anchor" href="#a-给-c-发数据包怎么知道是否要通过路由器转发呢"></a> A 给 C 发数据包，怎么知道是否要通过路由器转发呢？</h2><p><strong>答案：子网</strong></p><p>如果源 IP 与目的 IP 处于一个子网，直接将包通过交换机发出去。</p><p>如果源 IP 与目的 IP 不处于一个子网，就交给路由器去处理。</p><p>好，那现在只需要解决，什么叫处于一个子网就好了。</p><ul><li>192.168.0.1 和 192.168.0.2 处于同一个子网</li><li>192.168.0.1 和 192.168.1.1 处于不同子网</li></ul><p>这两个是我们人为规定的，即我们想表示，对于 192.168.0.1 来说：</p><p><strong><a href="http://192.168.0.xxx">192.168.0.xxx</a> 开头的，就算是在一个子网，否则就是在不同的子网。</strong></p><p>那对于计算机来说，怎么表达这个意思呢？于是人们发明了<strong>子网掩码</strong>的概念</p><p>假如某台机器的子网掩码定为 255.255.255.0</p><p>这表示，将源 IP 与目的 IP 分别同这个子网掩码进行<strong>与运算*<em>*</em>，相等则是在一个子网，不相等就是在不同子网</strong>，就这么简单。</p><p>比如</p><ul><li><strong>A电脑</strong>：192.168.0.1 &amp; 255.255.255.0 = 192.168.0.0</li><li><strong>B电脑</strong>：192.168.0.2 &amp; 255.255.255.0 = 192.168.0.0</li><li><strong>C电脑</strong>：192.168.1.1 &amp; 255.255.255.0 = 192.168.1.0</li><li><strong>D电脑</strong>：192.168.1.2 &amp; 255.255.255.0 = 192.168.1.0</li></ul><p>那么 A 与 B 在同一个子网，C 与 D 在同一个子网，但是 A 与 C 就不在同一个子网，与 D 也不在同一个子网，以此类推。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124155149.png" alt="" /></p><p>所以如果 A 给 C 发消息，A 和 C 的 IP 地址分别 &amp; A 机器配置的子网掩码，发现不相等，则 A 认为 C 和自己不在同一个子网，于是把包发给路由器，就不管了，<strong>之后怎么转发，A 不关心</strong>。</p><h2 id="a-如何知道哪个设备是路由器"><a class="markdownIt-Anchor" href="#a-如何知道哪个设备是路由器"></a> A 如何知道，哪个设备是路由器？</h2><p><strong>答案：在 A 上要设置默认网关</strong></p><p>上一步 A 通过是否与 C 在同一个子网内，判断出自己应该把包发给路由器，那路由器的 IP 是多少呢？</p><p>其实说发给路由器不准确，应该说 A 会把包发给<strong>默认网关</strong>。</p><p>对 A 来说，A 只能<strong>直接</strong>把包发给同处于一个子网下的某个 IP 上，所以发给路由器还是发给某个电脑，对 A 来说也不关心，只要这个设备有个 IP 地址就行。</p><p>所以<strong>默认网关，就是 A 在自己电脑里配置的一个 IP 地址</strong>，以便在发给不同子网的机器时，发给这个 IP 地址。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124155148.png" alt="" /></p><p>仅此而已！</p><h2 id="路由器如何知道c在哪里"><a class="markdownIt-Anchor" href="#路由器如何知道c在哪里"></a> 路由器如何知道C在哪里？</h2><p><strong>答案：路由表</strong></p><p>现在 A 要给 C 发数据包，已经可以成功发到路由器这里了，最后一个问题就是，<strong>路由器怎么知道，收到的这个数据包，该从自己的哪个端口出去</strong>，才能直接（或间接）地最终到达目的地 C 呢。</p><p>路由器收到的数据包有目的 IP 也就是 C 的 IP 地址，需要转化成从自己的哪个端口出去，很容易想到，应该有个表，就像 MAC 地址表一样。</p><p>这个表就叫<strong>路由表</strong>。</p><p>至于这个路由表是怎么出来的，有很多路由算法，本文不展开，因为我也不会哈哈~</p><p>不同于 MAC 地址表的是，路由表并不是一对一这种明确关系，我们下面看一个路由表的结构。</p><table><thead><tr><th>目的地址</th><th>子网掩码</th><th>下一跳</th><th>端口</th></tr></thead><tbody><tr><td>192.168.0.0</td><td>255.255.255.0</td><td></td><td>0</td></tr><tr><td>192.168.0.254</td><td>255.255.255.255</td><td></td><td>0</td></tr><tr><td>192.168.1.0</td><td>255.255.255.0</td><td></td><td>1</td></tr><tr><td>192.168.1.254</td><td>255.255.255.255</td><td></td><td>1</td></tr></tbody></table><p>我们学习一种新的表示方法，由于子网掩码其实就表示前多少位表示子网的网段，所以如 192.168.0.0（255.255.255.0） 也可以简写为 192.168.0.0/24</p><table><thead><tr><th>目的地址</th><th>下一跳</th><th>端口</th></tr></thead><tbody><tr><td>192.168.0.0/24</td><td></td><td>0</td></tr><tr><td>192.168.0.254/32</td><td></td><td>0</td></tr><tr><td>192.168.1.0/24</td><td></td><td>1</td></tr><tr><td>192.168.1.254/32</td><td></td><td>1</td></tr></tbody></table><p>这就很好理解了，路由表就表示，<strong><a href="http://192.168.0.xxx">192.168.0.xxx</a> 这个子网下的，都转发到 0 号端口，<a href="http://192.168.1.xxx">192.168.1.xxx</a> 这个子网下的，都转发到 1 号端口</strong>。下一跳列还没有值，我们先不管</p><p>配合着结构图来看（这里把子网掩码和默认网关都补齐了）图中 &amp; 笔误，结果应该是 .0</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124155145.gif" alt="" /></p><h2 id="刚才说的都是-ip-层但发送数据包的数据链路层需要知道-mac-地址可是我只知道-ip-地址该怎么办呢"><a class="markdownIt-Anchor" href="#刚才说的都是-ip-层但发送数据包的数据链路层需要知道-mac-地址可是我只知道-ip-地址该怎么办呢"></a> 刚才说的都是 IP 层，但发送数据包的数据链路层需要知道 MAC 地址，可是我只知道 IP 地址该怎么办呢？</h2><p><strong>答案：arp</strong></p><p>假如你（A）此时<strong>不知道</strong>你同伴 B 的 MAC 地址（现实中就是不知道的，刚刚我们只是假设已知），你只知道它的 IP 地址，你该怎么把数据包准确传给 B 呢？</p><p>答案很简单，在网络层，<strong>我需要把 IP 地址对应的 MAC 地址找到</strong>，也就是通过某种方式，找到 <strong>192.168.0.2</strong> 对应的 MAC 地址 <strong>BBBB</strong>。</p><p>这种方式就是 <strong>arp 协议</strong>，同时电脑 A 和 B 里面也会有一张 <strong>arp 缓存表</strong>，表中记录着 <strong>IP 与 MAC 地址</strong>的对应关系。</p><table><thead><tr><th>IP 地址</th><th>MAC 地址</th></tr></thead><tbody><tr><td>192.168.0.2</td><td>BBBB</td></tr></tbody></table><p>一开始的时候这个表是<strong>空的</strong>，电脑 A 为了知道电脑 B（192.168.0.2）的 MAC 地址，将会<strong>广播</strong>一条 arp 请求，B 收到请求后，带上自己的 MAC 地址给 A 一个<strong>响应</strong>。此时 A 便更新了自己的 arp 表。</p><p>这样通过大家不断广播 arp 请求，最终所有电脑里面都将 arp 缓存表更新完整。</p><p><strong>总结一下</strong></p><p>好了，总结一下，到目前为止就几条规则</p><p><strong>从各个节点的视角来看</strong></p><p><strong>电脑视角</strong>：</p><ul><li>首先我要知道我的 IP 以及对方的 IP</li><li>通过子网掩码判断我们是否在同一个子网</li><li>在同一个子网就通过 arp 获取对方 mac 地址直接扔出去</li><li>不在同一个子网就通过 arp 获取默认网关的 mac 地址直接扔出去</li></ul><p><strong>交换机视角：</strong></p><ul><li>我收到的数据包必须有目标 MAC 地址</li><li>通过 MAC 地址表查映射关系</li><li>查到了就按照映射关系从我的指定端口发出去</li><li>查不到就所有端口都发出去</li></ul><p><strong>路由器视角：</strong></p><ul><li>我收到的数据包必须有目标 IP 地址</li><li>通过路由表查映射关系</li><li>查到了就按照映射关系从我的指定端口发出去（不在任何一个子网范围，走其路由器的默认网关也是查到了）</li><li>查不到则返回一个路由不可达的数据包</li></ul><p>如果你嗅觉足够敏锐，你应该可以感受到下面这句话：</p><p>网络层（IP协议）本身没有传输包的功能，包的实际传输是委托给数据链路层（以太网中的交换机）来实现的。</p><p><strong>涉及到的三张表分别是</strong></p><ul><li>交换机中有 <strong>MAC 地址</strong>表用于映射 MAC 地址和它的端口</li><li>路由器中有<strong>路由表</strong>用于映射 IP 地址(段)和它的端口</li><li>电脑和路由器中都有 <strong>arp 缓存表</strong>用于缓存 IP 和 MAC 地址的映射关系</li></ul><p><strong>这三张表是怎么来的</strong></p><ul><li>MAC 地址表是通过以太网内各节点之间不断通过交换机通信，不断完善起来的。</li><li>路由表是各种路由算法 + 人工配置逐步完善起来的。</li><li>arp 缓存表是不断通过 arp 协议的请求逐步完善起来的。</li></ul><p>知道了以上这些，目前网络上两个节点是如何发送数据包的这个过程，就完全可以解释通了！</p><p>那接下来我们就放上本章 <strong>最后一个</strong> 网络拓扑图吧，请做好 <strong>战斗</strong> 准备！</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124155144.png" alt="" /></p><p>这时路由器 1 连接了路由器 2，所以其路由表有了下一条地址这一个概念，所以它的路由表就变成了这个样子。如果匹配到了有下一跳地址的一项，则需要再次匹配，找到其端口，并找到下一跳 IP 的 MAC 地址。</p><p>也就是说找来找去，最终必须能映射到一个端口号，然后从这个端口号把数据包发出去。</p><table><thead><tr><th>目的地址</th><th>下一跳</th><th>端口</th></tr></thead><tbody><tr><td>192.168.0.0/24</td><td></td><td>0</td></tr><tr><td>192.168.0.254/32</td><td></td><td>0</td></tr><tr><td>192.168.1.0/24</td><td></td><td>1</td></tr><tr><td>192.168.1.254/32</td><td></td><td>1</td></tr><tr><td>192.168.2.0/24</td><td>192.168.100.5</td><td></td></tr><tr><td>192.168.100.0/24</td><td></td><td>2</td></tr><tr><td>192.168.100.4/32</td><td></td><td>2</td></tr></tbody></table><p><strong>这时如果 A 给 F 发送一个数据包，能不能通呢？如果通的话整个过程是怎样的呢？</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124155143.png" alt="" /></p><p>思考一分钟…</p><p><strong>详细过程动画描述：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124155142.gif" alt="" /></p><p><strong>详细过程文字描述：</strong></p><p><strong>1.</strong> 首先 A（192.168.0.1）通过子网掩码（255.255.255.0）计算出自己与 F（192.168.2.2）并不在同一个子网内，于是决定发送给默认网关（192.168.0.254）</p><p><strong>2.</strong> A 通过 ARP 找到 默认网关 192.168.0.254 的 MAC 地址。</p><p><strong>3.</strong> A 将源 MAC 地址（AAAA）与网关 MAC 地址（ABAB）封装在数据链路层头部，又将源 IP 地址（192.168.0.1）和目的 IP 地址（192.168.2.2）（注意这里千万不要以为填写的是默认网关的 IP 地址，从始至终这个数据包的两个 IP 地址都是不变的，只有 MAC 地址在不断变化）封装在网络层头部，然后发包</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124155141.png" alt="" /></p><p><strong>4.</strong> 交换机 1 收到数据包后，发现目标 MAC 地址是 ABAB，转发给路由器1</p><p><strong>5.</strong> 数据包来到了路由器 1，发现其目标 IP 地址是 192.168.2.2，查看其路由表，发现了下一跳的地址是 192.168.100.5</p><p><strong>6.</strong> 所以此时路由器 1 需要做两件事，第一件是再次匹配路由表，发现匹配到了端口为 2，于是将其封装到数据链路层，最后把包从 2 号口发出去。</p><p><strong>7.</strong> 此时路由器 2 收到了数据包，看到其目的地址是 192.168.2.2，查询其路由表，匹配到端口号为 1，准备从 1 号口把数据包送出去。</p><p><strong>8.</strong> 但此时路由器 2 需要知道 192.168.2.2 的 MAC 地址了，于是查看其 arp 缓存，找到其 MAC 地址为 FFFF，将其封装在数据链路层头部，并从 1 号端口把包发出去。</p><p><strong>9.</strong> 交换机 3 收到了数据包，发现目的 MAC 地址为 FFFF，查询其 MAC 地址表，发现应该从其6 号端口出去，于是从 6 号端口把数据包发出去。</p><p><strong>10.</strong> F 最终收到了数据包！并且发现目的 MAC 地址就是自己，于是收下了这个包</p><h2 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h2><p>至此，经过物理层、数据链路层、网络层这前三层的协议，以及根据这些协议设计的各种网络设备（网线、集线器、交换机、路由器），理论上只要拥有对方的 IP 地址，就已经将地球上任意位置的两个节点连通了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202101/20210124155150.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;你是一台电脑，你的名字叫 A&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很久很久之前，你不与任何其他电脑相连接，孤苦伶仃。&lt;/p&gt;
&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-lazy-src=&quot;https://cdn.jsdelivr.</summary>
      
    
    
    
    <category term="网络" scheme="https://jitwxs.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Arthas 初探（6）——火焰图</title>
    <link href="https://jitwxs.cn/744744f8.html"/>
    <id>https://jitwxs.cn/744744f8.html</id>
    <published>2020-12-27T13:36:24.000Z</published>
    <updated>2020-12-27T14:12:16.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言"></a> 一、前言</h2><p><code>profiler</code> 命令支持生成应用热点的火焰图。本质上是通过不断的采样，然后把收集到的采样结果生成火焰图。</p><p>目前 profiler 命令还不支持在 Windows 下执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@18132]$</span><span class="bash"> profiler list</span></span><br><span class="line">AsyncProfiler error: Current OS do not support AsyncProfiler, Only support Linux/Mac.</span><br></pre></td></tr></table></figure><h2 id="二-基本使用"><a class="markdownIt-Anchor" href="#二-基本使用"></a> 二、基本使用</h2><p><code>profiler</code> 命令基本运行结构是 <code>profiler action [actionArg]</code></p><h3 id="21-参数说明"><a class="markdownIt-Anchor" href="#21-参数说明"></a> 2.1 参数说明</h3><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>action</em></td><td>要执行的操作</td></tr><tr><td><em>actionArg</em></td><td>属性名模式</td></tr><tr><td>[i:]</td><td>采样间隔（单位：ns）（默认值：10’000’000，即10 ms）</td></tr><tr><td>[f:]</td><td>将输出转储到指定路径</td></tr><tr><td>[d:]</td><td>运行评测指定秒</td></tr><tr><td>[e:]</td><td>要跟踪哪个事件（cpu, alloc, lock, cache-misses等），默认是 cpu</td></tr></tbody></table><h3 id="22-采样"><a class="markdownIt-Anchor" href="#22-采样"></a> 2.2 采样</h3><p>（1）启动 profiler</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@44]$</span><span class="bash"> profiler start</span></span><br><span class="line">Started [cpu] profiling</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，生成的是cpu的火焰图，即event为 <code>cpu</code>。可以用 <code>--event</code> 参数来指定。</p></blockquote><p>（2）获取已采集的 sample 的数量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@44]$</span><span class="bash"> profiler getSamples</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>（3）查看 profiler 状态</p><p>可以查看当前 profiler 在采样哪种 <code>event</code> 和采样时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@44]$</span><span class="bash"> profiler status</span></span><br><span class="line">[cpu] profiling is running for 51 seconds</span><br></pre></td></tr></table></figure><p>（4）停止 profiler</p><p>默认情况下，生成的格式为 svg 格式，且生成的结果保存到应用的 <code>工作目录</code> 下的 <code>arthas-output</code> 目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Started [cpu] profiling</span><br><span class="line"><span class="meta">[arthas@44]$</span><span class="bash"> profiler stop</span></span><br><span class="line">OK</span><br><span class="line">profiler output file: /mnt/c/Users/Jitwxs/Downloads/arthas-output/20201227-214951.svg</span><br></pre></td></tr></table></figure><p>可以通过 <code>--file</code> 参数来指定输出结果路径。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@44]$</span><span class="bash">  profiler stop --file ./output.svg</span></span><br><span class="line">OK</span><br><span class="line">profiler output file: ./output.svg</span><br></pre></td></tr></table></figure><p>如果需要生成 html 格式的，可以用 <code>--format</code> 参数指定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@44]$</span><span class="bash">  profiler stop --format html</span></span><br></pre></td></tr></table></figure><h3 id="23-渲染"><a class="markdownIt-Anchor" href="#23-渲染"></a> 2.3 渲染</h3><p>默认情况下，arthas使用3658端口，则可以打开： <a href="http://localhost:3658/arthas-output/">http://localhost:3658/arthas-output/</a> 查看到<code>arthas-output</code>目录下面的 profiler 结果，或者直接打开源文件即可。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227220120102.png" alt="image-20201227220120102" /></p><h3 id="24-event-支持"><a class="markdownIt-Anchor" href="#24-event-支持"></a> 2.4 event 支持</h3><p>在不同的平台，不同的OS下面，支持的events各有不同。可以通过 <code>profiler list</code> 命令查询。</p><h3 id="25-恢复采样"><a class="markdownIt-Anchor" href="#25-恢复采样"></a> 2.5 恢复采样</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@44]$</span><span class="bash"> profiler resume</span></span><br></pre></td></tr></table></figure><p><code>start</code>和<code>resume</code>的区别是：<code>start</code>是新开始采样，<code>resume</code>会保留上次<code>stop</code>时的数据。</p><p>通过执行<code>profiler getSamples</code>可以查看 samples 的数量来验证。</p><h3 id="26-framebuf-参数"><a class="markdownIt-Anchor" href="#26-framebuf-参数"></a> 2.6 framebuf 参数</h3><p>如果遇到生成的svg图片有 <code>[frame_buffer_overflow]</code>，则需要增大 framebuf（默认值是 1’000’000），可以显式配置，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@44]$</span><span class="bash"> profiler start --framebuf 5000000</span></span><br></pre></td></tr></table></figure><h3 id="27-过滤数据"><a class="markdownIt-Anchor" href="#27-过滤数据"></a> 2.7 过滤数据</h3><p>如果应用比较复杂，生成的内容很多，想只关注部分数据，可以通过 include/exclude 来过滤。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@44]$</span><span class="bash"> profiler start --include <span class="string">&#x27;java/*&#x27;</span> --include <span class="string">&#x27;demo/*&#x27;</span> --exclude <span class="string">&#x27;*Unsafe.park*&#x27;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>include/exclude 都支持设置多个值 ，但是需要配置在命令行的最后。</p></blockquote><h3 id="28-指定执行时间"><a class="markdownIt-Anchor" href="#28-指定执行时间"></a> 2.8 指定执行时间</h3><p>比如，希望 profiler 执行 300 秒自动结束，可以用 <code>-d</code>/<code>--duration</code> 参数指定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@44]$</span><span class="bash"> profiler start --duration 300</span></span><br></pre></td></tr></table></figure><h3 id="29-生成-jfr-格式结果"><a class="markdownIt-Anchor" href="#29-生成-jfr-格式结果"></a> 2.9 生成 jfr 格式结果</h3><p>jfr 只支持在 <code>start</code>时配置。如果是在 <code>stop</code> 时指定，则不会生效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@44]$</span><span class="bash"> profiler start --file /tmp/test.jfr</span></span><br></pre></td></tr></table></figure><p><code>file</code>参数支持一些变量：</p><ul><li>时间戳： <code>--file /tmp/test-%t.jfr</code></li><li>进程ID： <code>--file /tmp/test-%p.jfr</code></li></ul><p>生成的结果可以用支持jfr格式的工具来查看。比如：</p><ul><li>JDK Mission Control ： <a href="https://github.com/openjdk/jmc">https://github.com/openjdk/jmc</a></li><li>JProfiler ： <a href="https://github.com/alibaba/arthas/issues/1416">https://github.com/alibaba/arthas/issues/1416</a></li></ul><h3 id="三-火焰图分析"><a class="markdownIt-Anchor" href="#三-火焰图分析"></a> 三、火焰图分析</h3><p>火焰图是基于 perf 结果产生的SVG 图片，用来展示 CPU 的调用栈。</p><ul><li><p>y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。</p></li><li><p>x 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。</p></li></ul><p><strong>火焰图就是看顶层的哪个函数占据的宽度最大。只要有&quot;平顶&quot;（plateaus），就表示该函数可能存在性能问题。</strong></p><p>颜色没有特殊含义，因为火焰图表示的是 CPU 的繁忙程度，所以一般选择暖色调。</p><blockquote><p>可以参考阮一峰的文章：<a href="http://www.ruanyifeng.com/blog/2017/09/flame-graph.html">http://www.ruanyifeng.com/blog/2017/09/flame-graph.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-前言&quot;&gt;&lt;/a&gt; 一、前言&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;profiler&lt;/code&gt; 命令支持生成应用热点的火焰图。本质上是通过不断的采样，然后把收集到的采样结果生成火焰图。</summary>
      
    
    
    
    <category term="Java" scheme="https://jitwxs.cn/categories/Java/"/>
    
    <category term="性能分析" scheme="https://jitwxs.cn/categories/Java/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Arthas" scheme="https://jitwxs.cn/tags/Arthas/"/>
    
    <category term="火焰图" scheme="https://jitwxs.cn/tags/%E7%81%AB%E7%84%B0%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Arthas 初探（5）——核心命令</title>
    <link href="https://jitwxs.cn/5ed3293c.html"/>
    <id>https://jitwxs.cn/5ed3293c.html</id>
    <published>2020-12-27T12:01:49.000Z</published>
    <updated>2020-12-27T14:14:29.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言"></a> 一、前言</h2><p>在本章节中，将学习以下 Arthas 的核心命令，同时我也会附上官方文档的链接，方便大家查阅：</p><ul><li><p><a href="https://arthas.aliyun.com/doc/monitor.html">monitor</a> 方法执行监控</p></li><li><p><a href="https://arthas.aliyun.com/doc/watch.html">watch</a> 方法执行数据观测</p></li><li><p><a href="https://arthas.aliyun.com/doc/trace.html">trace</a> 方法内部调用路径，并输出方法路径上的每个节点上耗时</p></li><li><p><a href="https://arthas.aliyun.com/doc/stack.html">stack</a> 输出当前方法被调用的调用路径</p></li><li><p><a href="https://arthas.aliyun.com/doc/tt.html">tt</a> 记录下指定方法每次调用的入参和返回信息，并能对这些不同时间下调用的信息进行观测</p></li></ul><p>watch/trace/monitor/stack/tt 命令都支持 <code>-v</code> 参数。当命令执行之后，没有输出结果。有两种可能：</p><ol><li>匹配到的函数没有被执行</li><li>条件表达式结果是 false</li></ol><p>但用户区分不出是哪种情况。使用 <code>-v</code> 选项，则会打印 <code>Condition express</code> 的具体值和执行结果，方便确认。</p><h2 id="二-monitor"><a class="markdownIt-Anchor" href="#二-monitor"></a> 二、monitor</h2><p>对匹配 <code>class-pattern</code>／<code>method-pattern</code>／<code>condition-express</code>的类、方法的调用进行监控。</p><p><code>monitor</code> 命令是一个非实时返回命令。</p><blockquote><p>实时返回命令是输入之后立即返回，而非实时返回的命令，则是不断的等待目标 Java 进程返回信息，直到用户输入 <code>Ctrl+C</code> 为止。</p></blockquote><p>服务端是以任务的形式在后台跑任务，植入的代码随着任务的中止而不会被执行，所以任务关闭后，不会对原有性能产生太大影响，而且原则上，任何 Arthas 命令不会引起原有业务逻辑的改变。</p><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><em>method-pattern</em></td><td>方法名表达式匹配</td></tr><tr><td><em>condition-express</em></td><td>条件表达式</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr><tr><td><code>[c:]</code></td><td>统计周期，默认值为120秒</td></tr><tr><td>[b]</td><td>在<strong>方法调用之前</strong>计算condition-express</td></tr></tbody></table><h3 id="21-监控维度"><a class="markdownIt-Anchor" href="#21-监控维度"></a> 2.1 监控维度</h3><table><thead><tr><th>监控项</th><th>说明</th></tr></thead><tbody><tr><td>timestamp</td><td>时间戳</td></tr><tr><td>class</td><td>Java类</td></tr><tr><td>method</td><td>方法（构造方法、普通方法）</td></tr><tr><td>total</td><td>调用次数</td></tr><tr><td>success</td><td>成功次数</td></tr><tr><td>fail</td><td>失败次数</td></tr><tr><td>rt</td><td>平均RT</td></tr><tr><td>fail-rate</td><td>失败率</td></tr></tbody></table><h3 id="22-指定时间间隔监控指定方法"><a class="markdownIt-Anchor" href="#22-指定时间间隔监控指定方法"></a> 2.2 指定时间间隔监控指定方法</h3><p>每隔 5 秒监控一次类 demo.MathGame 中的 primeFactors 方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitor -c 5 demo.MathGame primeFactors</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227200943802.png" alt="" /></p><h3 id="23-方法执行后过滤统计结果"><a class="markdownIt-Anchor" href="#23-方法执行后过滤统计结果"></a> 2.3 方法执行后过滤统计结果</h3><p>方法执行后，每隔 5 秒监控一次类 demo.MathGame 中的 primeFactors 方法，筛选第一个参数 &lt;= 2 的数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitor -c 5 demo.MathGame primeFactors &quot;params[0] &lt;= 2&quot;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227201138631.png" alt="" /></p><h3 id="24-方法执行前过滤统计结果"><a class="markdownIt-Anchor" href="#24-方法执行前过滤统计结果"></a> 2.4 方法执行前过滤统计结果</h3><p>方法执行前，每隔 5 秒监控一次类 demo.MathGame 中的 primeFactors 方法，筛选第一个参数 &lt;= 2 的数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitor -b -c 5 demo.MathGame primeFactors &quot;params[0] &lt;= 2&quot;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227201229931.png" alt="" /></p><h2 id="三-watch"><a class="markdownIt-Anchor" href="#三-watch"></a> 三、watch</h2><p>能方便的观察到指定方法的调用情况。能观察到的范围为：<code>返回值</code>、<code>抛出异常</code>、<code>入参</code>，通过编写 OGNL 表达式进行对应变量的查看。</p><p>watch 的参数比较多，主要是因为它能在 4 个不同的场景观察对象：</p><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><em>method-pattern</em></td><td>方法名表达式匹配</td></tr><tr><td><em>express</em></td><td>观察表达式</td></tr><tr><td><em>condition-express</em></td><td>条件表达式</td></tr><tr><td>[b]</td><td>在<strong>方法调用之前</strong>观察</td></tr><tr><td>[e]</td><td>在<strong>方法异常之后</strong>观察</td></tr><tr><td>[s]</td><td>在<strong>方法返回之后</strong>观察</td></tr><tr><td>[f]</td><td>在<strong>方法结束之后</strong>(正常返回和异常返回)观察</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr><tr><td>[x:]</td><td>指定输出结果的属性遍历深度，默认为 1</td></tr></tbody></table><p>这里重点要说明的是观察表达式，观察表达式的构成主要由 ognl 表达式组成，所以你可以这样写 <code>&quot;&#123;params,returnObj&#125;&quot;</code>，只要是一个合法的 ognl 表达式，都能被正常支持。</p><h3 id="31-特别说明"><a class="markdownIt-Anchor" href="#31-特别说明"></a> 3.1 特别说明</h3><ul><li>watch 命令定义了4个观察事件点，即 <code>-b</code> 方法调用前，<code>-e</code> 方法异常后，<code>-s</code> 方法返回后，<code>-f</code> 方法结束后</li><li>4个观察事件点 <code>-b</code>、<code>-e</code>、<code>-s</code> 默认关闭，<code>-f</code> 默认打开，当指定观察点被打开后，在相应事件点会对观察表达式进行求值并输出</li><li>这里要注意 <code>方法入参</code> 和 <code>方法出参</code> 的区别，有可能在中间被修改导致前后不一致，除了 <code>-b</code> 事件点 <code>params</code> 代表方法入参外，其余事件都代表方法出参</li><li>当使用 <code>-b</code> 时，由于观察事件点是在方法调用前，此时返回值或异常均不存在</li></ul><h3 id="32-观察方法出参和返回值"><a class="markdownIt-Anchor" href="#32-观察方法出参和返回值"></a> 3.2 观察方法出参和返回值</h3><p>观察 demo.MathGame 类中 primeFactors 方法出参和返回值，结果属性遍历深度为 2。<br />params 表示所有参数数组(因为不确定是几个参数)，returnObject 表示返回值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors &quot;&#123;params,returnObj&#125;&quot; -x 2</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227201627726.png" alt="" /></p><h3 id="33-观察方法入参"><a class="markdownIt-Anchor" href="#33-观察方法入参"></a> 3.3 观察方法入参</h3><p>观察方法入参，对比前一个例子，返回值为空（事件点为方法执行前，因此获取不到返回值）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors &quot;&#123;params,returnObj&#125;&quot; -x 2 -b</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227201748514.png" alt="" /></p><h3 id="34-同时观察方法调用前和方法返回后"><a class="markdownIt-Anchor" href="#34-同时观察方法调用前和方法返回后"></a> 3.4 同时观察方法调用前和方法返回后</h3><p>同时观察方法调用前和方法返回后，参数里 <code>-n 2</code>，表示只执行两次（一前一后）。</p><ul><li><p>这里输出结果中，第一次输出的是方法调用前的观察表达式的结果，第二次输出的是方法返回后的表达式的结果</p></li><li><p>params 表示参数，target 表示执行方法的对象，returnObject 表示返回值</p></li><li><p>结果的输出顺序和事件发生的先后顺序一致，和命令中 <code>-s -b</code> 的顺序无关</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors &quot;&#123;params,target,returnObj&#125;&quot; -x 2 -b -s -n 2</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227202109565.png" alt="" /></p><h3 id="35-观察当前对象中的属性"><a class="markdownIt-Anchor" href="#35-观察当前对象中的属性"></a> 3.5 观察当前对象中的属性</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors &#x27;target&#x27; -x 2 -n 1</span><br></pre></td></tr></table></figure><p>如果觉得深度不够的话，可以调整 -x 的值，来看的更仔细。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227202340548.png" alt="" /></p><p>然后使用 <code>target.field_name</code> 访问当前对象的某个属性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@18132]$</span><span class="bash"> watch demo.MathGame primeFactors <span class="string">&#x27;target.illegalArgumentCount&#x27;</span> -x 2 -n 1</span></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class count: 1 , method count: 1) cost in 19 ms, listenerId: 23</span><br><span class="line">ts=2020-12-27 20:32:15; [cost=0.0806ms] result=@Integer[1300]</span><br><span class="line">Command execution times exceed limit: 1, so command will exit. You can set it with -n option.</span><br></pre></td></tr></table></figure><h3 id="36-条件表达式例子"><a class="markdownIt-Anchor" href="#36-条件表达式例子"></a> 3.6 条件表达式例子</h3><p>只有满足条件表达式的调用，才会有响应。监控第一个出参小于 0 的调用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors &quot;&#123;params[0],target&#125;&quot; &quot;params[0]&lt;0&quot;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227202525578.png" alt="" /></p><h3 id="37-观察异常信息的例子"><a class="markdownIt-Anchor" href="#37-观察异常信息的例子"></a> 3.7 观察异常信息的例子</h3><p>监控抛出异常的调用，并打印第一个出参：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors &quot;&#123;params[0],throwExp&#125;&quot; -e -x 2</span><br></pre></td></tr></table></figure><ul><li><code>-e</code> 表示抛出异常时才触发</li><li>express 中，表示异常信息的变量是 <code>throwExp</code></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227202733330.png" alt="" /></p><h3 id="38-按照耗时进行过滤"><a class="markdownIt-Anchor" href="#38-按照耗时进行过滤"></a> 3.8 按照耗时进行过滤</h3><p><code>#cost&gt;200</code> (单位是<code>ms</code>)表示只有当耗时大于 200ms 时才会输出，过滤掉执行时间小于 200ms 的调用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors &#x27;&#123;params, returnObj&#125;&#x27; &#x27;#cost&gt;200&#x27; -x 2</span><br></pre></td></tr></table></figure><blockquote><p>watch / stack / trace 这个三个命令都支持 <code>#cost</code></p></blockquote><h2 id="四-trace"><a class="markdownIt-Anchor" href="#四-trace"></a> 四、trace</h2><p><code>trace</code> 命令能主动搜索 <code>class-pattern</code> / <code>method-pattern</code> 对应的方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。</p><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><em>method-pattern</em></td><td>方法名表达式匹配</td></tr><tr><td><em>condition-express</em></td><td>条件表达式</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr><tr><td><code>[n:]</code></td><td>命令执行次数</td></tr><tr><td><code>#cost</code></td><td>方法执行耗时</td></tr></tbody></table><p>这里重点要说明的是观察表达式，观察表达式的构成主要由 ognl 表达式组成，所以你可以这样写 <code>&quot;&#123;params,returnObj&#125;&quot;</code>，只要是一个合法的 ognl 表达式，都能被正常支持。</p><h3 id="41-注意事项"><a class="markdownIt-Anchor" href="#41-注意事项"></a> 4.1 注意事项</h3><p><code>trace</code> 能方便的帮助你定位和发现因 RT 高而导致的性能问题缺陷，但其每次只能跟踪一级方法的调用链路。</p><p>参考：<a href="https://github.com/alibaba/arthas/issues/597">Trace命令的实现原理</a></p><p>3.3.0 起支持使用动态 Trace 功能，不断增加新的匹配类，参考下面的示例。</p><h3 id="42-trace-函数"><a class="markdownIt-Anchor" href="#42-trace-函数"></a> 4.2 trace 函数</h3><p>trace 函数指定类的指定方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace demo.MathGame run</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227204005224.png" alt="" /></p><p>如果方法调用的次数很多，那么可以用 -n 参数指定捕捉结果的次数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace demo.MathGame run -n 1</span><br></pre></td></tr></table></figure><h3 id="43-包含-jdk-函数"><a class="markdownIt-Anchor" href="#43-包含-jdk-函数"></a> 4.3 包含 JDK 函数</h3><p>默认情况下，trace 不会包含 JDK 里的函数调用，如果希望 trace JDK 里的函数，需要显式设置 <code>--skipJDKMethod false</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace --skipJDKMethod false demo.MathGame run</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227204136928.png" alt="" /></p><h3 id="44-按照调用耗时进行过滤"><a class="markdownIt-Anchor" href="#44-按照调用耗时进行过滤"></a> 4.4 按照调用耗时进行过滤</h3><p>只会展示耗时大于 1ms 的调用路径，有助于在排查问题的时候，只关注异常情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace demo.MathGame run &#x27;#cost &gt; 1&#x27;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227204311307.png" alt="" /></p><ul><li><code>trace</code> 在执行的过程中本身是会有一定的性能开销，在统计的报告中并未像 JProfiler 一样预先减去其自身的统计开销。所以这统计出来有些许的不准，渲染路径上调用的类、方法越多，性能偏差越大。但还是能让你看清一些事情的。</li><li>这里存在一个统计不准确的问题，就是所有方法耗时加起来可能会小于该监测方法的总耗时，这个是由于 Arthas 本身的逻辑会有一定的耗时。</li></ul><h3 id="45-trace-多个类或者多个函数"><a class="markdownIt-Anchor" href="#45-trace-多个类或者多个函数"></a> 4.5 trace 多个类或者多个函数</h3><p>trace 命令只会 trace 匹配到的函数里的子调用，并不会向下 trace 多层。因为 trace 是代价比较贵的，多层 trace 可能会导致最终要 trace 的类和函数非常多。</p><p>可以用正则表匹配路径上的多个类和函数，一定程度上达到多层 trace 的效果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace -E com.test.ClassA|org.test.ClassB method1|method2|method3</span><br></pre></td></tr></table></figure><h3 id="46-动态-trace"><a class="markdownIt-Anchor" href="#46-动态-trace"></a> 4.6 动态 trace</h3><p>打开终端1，trace 上面 demo 里的 <code>run</code> 函数，可以看到打印出 <code>listenerId: 1</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[arthas@59161]$ trace demo.MathGame run</span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class count: 1 , method count: 1) cost in 112 ms, listenerId: 1</span><br><span class="line">&#96;---ts&#x3D;2020-07-09 16:48:11;thread_name&#x3D;main;id&#x3D;1;is_daemon&#x3D;false;priority&#x3D;5;TCCL&#x3D;sun.misc.Launcher$AppClassLoader@3d4eac69</span><br><span class="line">    &#96;---[1.389634ms] demo.MathGame:run()</span><br><span class="line">        &#96;---[0.123934ms] demo.MathGame:primeFactors() #24 [throws Exception]</span><br><span class="line"> </span><br><span class="line">&#96;---ts&#x3D;2020-07-09 16:48:12;thread_name&#x3D;main;id&#x3D;1;is_daemon&#x3D;false;priority&#x3D;5;TCCL&#x3D;sun.misc.Launcher$AppClassLoader@3d4eac69</span><br><span class="line">    &#96;---[3.716391ms] demo.MathGame:run()</span><br><span class="line">        +---[3.182813ms] demo.MathGame:primeFactors() #24</span><br><span class="line">        &#96;---[0.167786ms] demo.MathGame:print() #25</span><br></pre></td></tr></table></figure><p>现在想要深入子函数 <code>primeFactors</code>，可以打开一个新终端2，使用 <code>telnet localhost 3658</code> 连接上arthas，再 trace <code>primeFactors</code> 时，指定 <code>listenerId</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[arthas@59161]$ trace demo.MathGame primeFactors --listenerId 1</span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class count: 1 , method count: 1) cost in 34 ms, listenerId: 1</span><br></pre></td></tr></table></figure><p>这时终端 2 打印的结果，说明已经增强了一个函数：<code>Affect(class count: 1 , method count: 1)</code>，但不再打印更多的结果。</p><p>再查看终端1，可以发现trace的结果增加了一层，打印了<code>primeFactors</code>函数里的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#96;---ts&#x3D;2020-07-09 16:49:29;thread_name&#x3D;main;id&#x3D;1;is_daemon&#x3D;false;priority&#x3D;5;TCCL&#x3D;sun.misc.Launcher$AppClassLoader@3d4eac69</span><br><span class="line">    &#96;---[0.492551ms] demo.MathGame:run()</span><br><span class="line">        &#96;---[0.113929ms] demo.MathGame:primeFactors() #24 [throws Exception]</span><br><span class="line">            &#96;---[0.061462ms] demo.MathGame:primeFactors()</span><br><span class="line">                &#96;---[0.001018ms] throw:java.lang.IllegalArgumentException() #46</span><br><span class="line"> </span><br><span class="line">&#96;---ts&#x3D;2020-07-09 16:49:30;thread_name&#x3D;main;id&#x3D;1;is_daemon&#x3D;false;priority&#x3D;5;TCCL&#x3D;sun.misc.Launcher$AppClassLoader@3d4eac69</span><br><span class="line">    &#96;---[0.409446ms] demo.MathGame:run()</span><br><span class="line">        +---[0.232606ms] demo.MathGame:primeFactors() #24</span><br><span class="line">        |   &#96;---[0.1294ms] demo.MathGame:primeFactors()</span><br><span class="line">        &#96;---[0.084025ms] demo.MathGame:print() #25</span><br></pre></td></tr></table></figure><p>通过指定<code>listenerId</code>的方式动态 trace，可以不断深入。另外 <code>watch</code>/<code>tt</code>/<code>monitor</code> 等命令也支持类似的功能。</p><h2 id="五-stack"><a class="markdownIt-Anchor" href="#五-stack"></a> 五、stack</h2><p>很多时候我们都知道一个方法被执行，但这个方法被执行的路径非常多，或者你根本就不知道这个方法是从那里被执行了，此时你需要的是 stack 命令。</p><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><em>method-pattern</em></td><td>方法名表达式匹配</td></tr><tr><td><em>condition-express</em></td><td>条件表达式</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr><tr><td><code>[n:]</code></td><td>执行次数限制</td></tr></tbody></table><p>这里重点要说明的是观察表达式，观察表达式的构成主要由 ognl 表达式组成，所以你可以这样写 <code>&quot;&#123;params,returnObj&#125;&quot;</code>，只要是一个合法的 ognl 表达式，都能被正常支持。</p><h3 id="51-获取方法的调用路径"><a class="markdownIt-Anchor" href="#51-获取方法的调用路径"></a> 5.1 获取方法的调用路径</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack demo.MathGame primeFactors</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227205138934.png" alt="" /></p><h3 id="52-条件表达式来过滤"><a class="markdownIt-Anchor" href="#52-条件表达式来过滤"></a> 5.2 条件表达式来过滤</h3><p>第 0 个参数的值小于 0，-n 表示获取 2 次</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack demo.MathGame primeFactors &#x27;params[0]&lt;0&#x27; -n 2</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227205230546.png" alt="" /></p><h3 id="53-按照执行时间进行过滤"><a class="markdownIt-Anchor" href="#53-按照执行时间进行过滤"></a> 5.3 按照执行时间进行过滤</h3><p>过滤耗时大于0.5毫秒</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack demo.MathGame primeFactors &#x27;#cost&gt;0.5&#x27;</span><br></pre></td></tr></table></figure><h2 id="六-tt"><a class="markdownIt-Anchor" href="#六-tt"></a> 六、tt</h2><p><code>watch</code> 虽然很方便和灵活，但需要提前想清楚观察表达式的拼写，这对排查问题而言要求太高，因为很多时候我们并不清楚问题出自于何方，只能靠蛛丝马迹进行猜测。</p><p>这个时候如果能记录下当时方法调用的所有入参和返回值、抛出的异常会对整个问题的思考与判断非常有帮助。</p><p>于是乎，TimeTunnel （时间隧道）命令就诞生了。</p><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td>-t</td><td>记录某个方法在一个时间段中的调用</td></tr><tr><td>-l</td><td>显示所有已经记录的列表</td></tr><tr><td>-n 次数</td><td>只记录多少次</td></tr><tr><td>-s 表达式</td><td>搜索表达式</td></tr><tr><td>-i 索引号</td><td>查看指定索引号的详细调用信息</td></tr><tr><td>-p</td><td>重新调用指定的索引号时间碎片</td></tr></tbody></table><h3 id="61-记录调用"><a class="markdownIt-Anchor" href="#61-记录调用"></a> 6.1 记录调用</h3><p>最基本的使用来说，就是记录下当前方法的每次调用环境现场</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -t demo.MathGame primeFactors</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227210237832.png" alt="" /></p><table><thead><tr><th>表格字段</th><th>字段解释</th></tr></thead><tbody><tr><td>INDEX</td><td>时间片段记录编号，每一个编号代表着一次调用，后续tt还有很多命令都是基于此编号指定记录操作，非常重要。</td></tr><tr><td>TIMESTAMP</td><td>方法执行的本机时间，记录了这个时间片段所发生的本机时间</td></tr><tr><td>COST(ms)</td><td>方法执行的耗时</td></tr><tr><td>IS-RET</td><td>方法是否以正常返回的形式结束</td></tr><tr><td>IS-EXP</td><td>方法是否以抛异常的形式结束</td></tr><tr><td>OBJECT</td><td>执行对象的 <code>hashCode()</code>，注意，曾经有人误认为是对象在 JVM 中的内存地址，但很遗憾它不是，但它能帮助你简单的标记当前执行方法的类实体。</td></tr><tr><td>CLASS</td><td>执行的类名</td></tr><tr><td>METHOD</td><td>执行的方法名</td></tr></tbody></table><ul><li><p>条件表达式</p><p>不知道大家是否有在使用过程中遇到以下困惑</p><ul><li>Arthas 似乎很难区分出重载的方法</li><li>我只需要观察特定参数，但是 tt 却全部都给我记录了下来</li></ul><p>条件表达式也是用 <code>OGNL</code> 来编写，核心的判断对象依然是 <code>Advice</code> 对象。除了 <code>tt</code> 命令之外，<code>watch</code>、<code>trace</code>、<code>stack</code> 命令也都支持条件表达式。</p></li><li><p>解决方法重载</p><p><code>tt -t *Test print params.length==1</code></p><p>通过指定参数个数的形式解决不同的方法签名，如果参数个数一样，你还可以这样写</p><p><code>tt -t *Test print 'params[1] instanceof Integer'</code></p></li><li><p>解决指定参数</p><p><code>tt -t *Test print params[0].mobile==&quot;13989838402&quot;</code></p></li></ul><h3 id="62-检索调用记录"><a class="markdownIt-Anchor" href="#62-检索调用记录"></a> 6.2 检索调用记录</h3><p>当你用 <code>tt</code> 记录了一大片的时间片段之后，你希望能从中筛选出自己需要的时间片段，这个时候你就需要对现有记录进行检索。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -l</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227210522544.png" alt="" /></p><p>筛选出异常方法的调用信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -s &quot;isThrow==true&quot;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227211459017.png" alt="" /></p><h3 id="63-查看调用信息"><a class="markdownIt-Anchor" href="#63-查看调用信息"></a> 6.3 查看调用信息</h3><p>对于具体一个时间片的信息而言，你可以通过 <code>-i</code> 参数后边跟着对应的 <code>INDEX</code> 编号查看到他的详细信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -i 1000</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227211603717.png" alt="" /></p><h3 id="64-重做一次调用"><a class="markdownIt-Anchor" href="#64-重做一次调用"></a> 6.4 重做一次调用</h3><p>当你稍稍做了一些调整之后，你可能需要前端系统重新触发一次你的调用，此时得求爷爷告奶奶的需要前端配合联调的同学再次发起一次调用。而有些场景下，这个调用不是这么好触发的。</p><p><code>tt</code> 命令由于保存了当时调用的所有现场信息，所以我们可以自己主动对一个 <code>INDEX</code> 编号的时间片自主发起一次调用，从而解放你的沟通成本。此时你需要 <code>-p</code> 参数。通过 <code>--replay-times</code> 指定 调用次数，通过 <code>--replay-interval</code> 指定多次调用间隔(单位ms, 默认1000ms)</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227211803317.png" alt="" /></p><p>你会发现结果虽然一样，但调用的路径发生了变化，由原来的程序发起变成了 Arthas 自己的内部线程发起的调用了。</p><p>需要强调的点：</p><ol><li><p><strong>ThreadLocal 信息丢失</strong></p><p>很多框架偷偷的将一些环境变量信息塞到了发起调用线程的 ThreadLocal 中，由于调用线程发生了变化，这些 ThreadLocal 线程信息无法通过 Arthas 保存，所以这些信息将会丢失。</p></li><li><p><strong>引用的对象</strong></p><p>需要强调的是，<code>tt</code> 命令是将当前环境的对象引用保存起来，但仅仅也只能保存一个引用而已。如果方法内部对入参进行了变更，或者返回的对象经过了后续的处理，那么在 <code>tt</code> 查看的时候将无法看到当时最准确的值。这也是为什么 <code>watch</code> 命令存在的意义。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-前言&quot;&gt;&lt;/a&gt; 一、前言&lt;/h2&gt;
&lt;p&gt;在本章节中，将学习以下 Arthas 的核心命令，同时我也会附上官方文档的链接，方便大家查阅：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="Java" scheme="https://jitwxs.cn/categories/Java/"/>
    
    <category term="性能分析" scheme="https://jitwxs.cn/categories/Java/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Arthas" scheme="https://jitwxs.cn/tags/Arthas/"/>
    
  </entry>
  
  <entry>
    <title>Arthas 初探（4）——Class 命令</title>
    <link href="https://jitwxs.cn/43dc34ff.html"/>
    <id>https://jitwxs.cn/43dc34ff.html</id>
    <published>2020-12-27T08:55:36.000Z</published>
    <updated>2020-12-27T14:14:23.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言"></a> 一、前言</h2><p>在本章节中，将学习以下 Arthas 的 Class 相关命令，同时我也会附上官方文档的链接，方便大家查阅：</p><ul><li><a href="https://arthas.aliyun.com/doc/sc.html">sc</a> Search Class 查看运行中的类信息</li><li><a href="https://arthas.aliyun.com/doc/sm.html">sm</a> Search Method 查看类中方法的信息</li><li><a href="https://arthas.aliyun.com/doc/jad.html">jad</a> 反编译字节码为源代码</li><li><a href="https://arthas.aliyun.com/doc/mc.html">mc</a> Memory Compile 将源代码编译成字节码</li><li><a href="https://arthas.aliyun.com/doc/redefine.html">redefine</a> 将编译好的字节码文件加载到 JVM 中运行</li><li><a href="https://arthas.aliyun.com/doc/dump.html">dump</a> 将已加载类的 bytecode 下载到特定目录</li><li><a href="https://arthas.aliyun.com/doc/classloader.html">classloader</a> 查看 classloader 的继承树，urls，类加载信息</li></ul><h2 id="二-sc"><a class="markdownIt-Anchor" href="#二-sc"></a> 二、sc</h2><p><code>sc</code> 是 Search-Class 的缩写，用于查看 JVM 已加载的类信息，这个命令能搜索出所有已经加载到 JVM 中的 Class 信息。</p><blockquote><p>class-pattern支持全限定名，如com.taobao.test.AAA，也支持com/taobao/test/AAA 这样的格式，这样，我们从异常堆栈里面把类名拷贝过来的时候，不需要在手动把 <code>/</code> 替换为 <code>.</code></p><p>sc 默认开启了子类匹配功能，也就是说所有当前类的子类也会被搜索出来，想要精确的匹配，请打开 <code>options disable-sub-class true</code> 开关。</p></blockquote><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><em>method-pattern</em></td><td>方法名表达式匹配</td></tr><tr><td>[d]</td><td>输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的ClassLoader等详细信息。 如果一个类被多个ClassLoader所加载，则会出现多次</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr><tr><td>[f]</td><td>输出当前类的成员变量信息（需要配合参数-d一起使用）</td></tr><tr><td>[x:]</td><td>指定输出静态变量时属性的遍历深度，默认为 0，即直接使用 <code>toString</code> 输出</td></tr><tr><td><code>[c:]</code></td><td>指定class的 ClassLoader 的 hashcode</td></tr><tr><td><code>[classLoaderClass:]</code></td><td>指定执行表达式的 ClassLoader 的 class name</td></tr><tr><td><code>[n:]</code></td><td>具有详细信息的匹配类的最大数量（默认为100）</td></tr></tbody></table><p>（1）模糊搜索，demo 包下所有的类</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@6096]$</span><span class="bash"> sc demo.*</span></span><br><span class="line">demo.MathGame</span><br><span class="line">Affect(row-cnt:1) cost in 81 ms.sc demo.*</span><br></pre></td></tr></table></figure><p>（2）打印 demo.MathGame 类的详细信息</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227170419829.png" alt="" /></p><p>（3）打印 demo.MathGame 类的详细信息 + 变量信息</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227170644232.png" alt="" /></p><h2 id="三-sm"><a class="markdownIt-Anchor" href="#三-sm"></a> 三、sm</h2><p><code>sm</code> 是 Search-Method 的简写，这个命令能搜索出所有已经加载了 Class 信息的方法信息。</p><p><code>sm</code> 命令只能看到由当前类所声明 (declaring) 的方法，父类则无法看到。</p><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><em>method-pattern</em></td><td>方法名表达式匹配</td></tr><tr><td>[d]</td><td>展示每个方法的详细信息</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr><tr><td><code>[c:]</code></td><td>指定class的 ClassLoader 的 hashcode</td></tr><tr><td><code>[classLoaderClass:]</code></td><td>指定执行表达式的 ClassLoader 的 class name</td></tr><tr><td><code>[n:]</code></td><td>具有详细信息的匹配类的最大数量（默认为100）</td></tr></tbody></table><p>（1）显示 String 类加载的方法</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227170848562.png" alt="" /></p><p>（2）显示 String 中的 toString 方法详细信息</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227170925022.png" alt="" /></p><h2 id="三-jad"><a class="markdownIt-Anchor" href="#三-jad"></a> 三、jad</h2><p><code>jad</code> 命令的主要工作是反编译，将 JVM 中实际运行的 class 的 byte code 反编译成 java 代码，便于你理解业务逻辑。</p><ul><li>在 Arthas Console 上，反编译出来的源码是带语法高亮的，阅读更方便</li><li>当然，反编译出来的 java 代码可能会存在语法错误，但不影响你进行阅读理解</li></ul><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><code>[c:]</code></td><td>类所属 ClassLoader 的 hashcode</td></tr><tr><td><code>[classLoaderClass:]</code></td><td>指定执行表达式的 ClassLoader 的 class name</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr></tbody></table><h3 id="31-编译-string-类"><a class="markdownIt-Anchor" href="#31-编译-string-类"></a> 3.1 编译 String 类</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad &lt;class-pattern&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227171138038.png" alt="" /></p><h3 id="32-反编译时只显示源代码"><a class="markdownIt-Anchor" href="#32-反编译时只显示源代码"></a> 3.2 反编译时只显示源代码</h3><p>默认情况下，反编译结果里会带有 <code>ClassLoader</code> 信息，通过 <code>--source-only</code> 选项，可以只打印源代码。方便和 <a href="https://arthas.aliyun.com/doc/mc.html">mc</a>/<a href="https://arthas.aliyun.com/doc/redefine.html">redefine</a> 命令结合使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad --source-only &lt;class-pattern&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227171243641.png" alt="" /></p><h3 id="33-反编译指定的函数"><a class="markdownIt-Anchor" href="#33-反编译指定的函数"></a> 3.3 反编译指定的函数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad &lt;class-pattern&gt; &lt;method-pattern&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227171402394.png" alt="" /></p><h2 id="四-mc"><a class="markdownIt-Anchor" href="#四-mc"></a> 四、mc</h2><p><code>mc</code> 是 Memory Compiler 的缩写，编译 <code>.java</code> 文件生成 <code>.class</code> 。</p><p>（1）在内存中编译 Hello.java 为 Hello.class</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mc /root/Hello.java</span><br></pre></td></tr></table></figure><p>（2）可以通过 -d 命令指定输出目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mc -d /root/bbb /root/Hello.java</span><br></pre></td></tr></table></figure><h2 id="五-redefine"><a class="markdownIt-Anchor" href="#五-redefine"></a> 五、redefine</h2><p>加载外部的 <code>.class</code> 文件，redefine JVM 已加载的类。</p><p>注意， redefine 后的原来的类不能恢复，redefine 有可能失败（比如增加了新的 field），参考 JDK 本身的文档。</p><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td>[c:]</td><td>ClassLoader的hashcode</td></tr><tr><td><code>[classLoaderClass:]</code></td><td>指定执行表达式的 ClassLoader 的 class name</td></tr><tr><td>[p:]</td><td>外部的<code>.class</code>文件的完整路径，支持多个</td></tr></tbody></table><h3 id="51-自身限制"><a class="markdownIt-Anchor" href="#51-自身限制"></a> 5.1 自身限制</h3><ul><li>不允许新增加 field / method</li><li>正在跑的函数，没有退出不能生效，比如下面新增加的 <code>System.out.println</code>，只有 <code>run()</code> 函数里的会生效</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MathGame game = <span class="keyword">new</span> MathGame();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            game.run();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 这个不生效，因为代码一直跑在 while里</span></span><br><span class="line">            System.out.println(<span class="string">&quot;in loop&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 这个生效，因为run()函数每次都可以完整结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;call run()&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> number = random.nextInt();</span><br><span class="line">            List&lt;Integer&gt; primeFactors = primeFactors(number);</span><br><span class="line">            print(number, primeFactors);</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;illegalArgumentCount:%3d, &quot;</span>, illegalArgumentCount) + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="52-命令冲突"><a class="markdownIt-Anchor" href="#52-命令冲突"></a> 5.2 命令冲突</h3><ul><li><code>reset</code> 命令对 <code>redefine</code> 的类无效。如果想重置，需要 <code>redefine</code> 原始的字节码。</li><li><code>redefine</code> 命令和 <code>jad</code>/<code>watch</code>/<code>trace</code>/<code>monitor</code>/<code>tt</code> 等命令会冲突。执行完<code>redefine</code> 之后，如果再执行上面提到的命令，则会把 <code>redefine</code> 的字节码重置。 原因是 JDK 本身 redefine 和 Retransform 是不同的机制，同时使用两种机制来更新字节码，只有最后修改的会生效。</li></ul><h3 id="53-实战"><a class="markdownIt-Anchor" href="#53-实战"></a> 5.3 实战</h3><p>（1）反编译 MathGame 类</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad demo.MathGame &gt; MathGame.java</span><br></pre></td></tr></table></figure><p>（2）编辑该类，增加两行输出。一行在 main 方法死循环中，一行在 run() 方法首行。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227191848404.png" alt="" /></p><p>（2）编译修改后的类</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mc -d C://Users//Jitwxs//Downloads//MathGame.java C://Users//Jitwxs//Downloads</span><br></pre></td></tr></table></figure><blockquote><p>原谅我这边没有截图，因为我在 Windows 电脑上执行 mc 命令失败了。</p><p>先是提示我 Can not load JavaCompiler from javax.tools.ToolProvider#getSystemJavaCompiler(), please confirm the application running in JDK not JRE。</p><p>解决后又报 FileNotFoundException: C:\Users\Jitwxs\Downloads (拒绝访问) 的错。</p><p>这就告诉我们，虽然是跨平台的，但还是不要用 Windows 去做命令行开发，否则慢慢踩坑吧。。</p></blockquote><p>（3）加载最新的字节码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redefine C://Users//Jitwxs//Downloads//MathGame.class</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227193548404.png" alt="" /></p><h3 id="56-上传-class-文件到服务器的技巧"><a class="markdownIt-Anchor" href="#56-上传-class-文件到服务器的技巧"></a> 5.6 上传 .class 文件到服务器的技巧</h3><p>使用 <code>mc</code> 命令来编译 <code>jad</code> 的反编译的代码有可能失败。可以在本地修改代码，编译好后再上传到服务器上。有的服务器不允许直接上传文件，可以使用 <code>base64</code> 命令来绕过。</p><ol><li><p>在本地先转换 <code>.class</code> 文件为 base64，再保存为 result.txt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base64 &lt; Test.class &gt; result.txt</span><br></pre></td></tr></table></figure></li><li><p>到服务器上，新建并编辑 <code>result.txt</code>，复制本地的内容，粘贴再保存</p></li><li><p>把服务器上的 <code>result.txt</code> 还原为 <code>.class</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base64 -d &lt; result.txt &gt; Test.class</span><br></pre></td></tr></table></figure></li><li><p>用 MD5 命令计算哈希值，校验是否一致</p></li></ol><h2 id="六-dump"><a class="markdownIt-Anchor" href="#六-dump"></a> 六、dump</h2><p>dump 已加载类的 bytecode 到特定目录。</p><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><code>[c:]</code></td><td>类所属 ClassLoader 的 hashcode</td></tr><tr><td><code>[classLoaderClass:]</code></td><td>指定执行表达式的 ClassLoader 的 class name</td></tr><tr><td><code>[d:]</code></td><td>设置类文件的目标目录</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr></tbody></table><p>（1）把 String 类的字节码文件保存到当前目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@18132]$</span><span class="bash"> dump java.lang.String -d .</span></span><br><span class="line"> HASHCODE  CLASSLOADER  LOCATION</span><br><span class="line"> null                   C:\Users\Jitwxs\Downloads\java\lang\String.class</span><br><span class="line">Affect(row-cnt:1) cost in 11 ms.</span><br></pre></td></tr></table></figure><p>（2）把 demo 包下所有的类的字节码文件保存到当前目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@18132]$</span><span class="bash"> dump demo.* -d .</span></span><br><span class="line"> HASHCODE  CLASSLOADER                                    LOCATION</span><br><span class="line"> 5c647e05  +-sun.misc.Launcher$AppClassLoader@5c647e05    C:\Users\Jitwxs\logs\arthas\classdump\sun.misc.Launcher$Ap</span><br><span class="line">             +-sun.misc.Launcher$ExtClassLoader@28d93b30  pClassLoader-5c647e05\demo\MathGame.class</span><br><span class="line">Affect(row-cnt:1) cost in 10 ms.</span><br></pre></td></tr></table></figure><h2 id="七-classloader"><a class="markdownIt-Anchor" href="#七-classloader"></a> 七、classloader</h2><p><code>classloader</code> 命令将 JVM 中所有的classloader的信息统计出来，并可以展示继承树，urls等。</p><p>可以让指定的 classloader 去 getResources，打印出所有查找到的 resources 的 url。对于 <code>ResourceNotFoundException</code> 比较有用。</p><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td>[l]</td><td>按类加载实例进行统计</td></tr><tr><td>[t]</td><td>打印所有ClassLoader的继承树</td></tr><tr><td>[a]</td><td>列出所有ClassLoader加载的类，请谨慎使用</td></tr><tr><td><code>[c:]</code></td><td>ClassLoader的hashcode</td></tr><tr><td><code>[classLoaderClass:]</code></td><td>指定执行表达式的 ClassLoader 的 class name</td></tr><tr><td><code>[c: r:]</code></td><td>用ClassLoader去查找resource</td></tr><tr><td><code>[c: load:]</code></td><td>用ClassLoader去加载指定的类</td></tr></tbody></table><p>（1）按类加载器的类型查看统计信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloadaer</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227195250913.png" alt="image-20201227195250913" /></p><p>（2）按类加载实例查看统计信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloadaer -l</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227195416801.png" alt="" /></p><p>（3）查看 ClassLoader 的继承树</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloadaer -t</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227195450749.png" alt="" /></p><p>（4）通过类加载器的 hash，查看此类加载器实际所在的位置</p><blockquote><p>注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。对于只有唯一实例的 ClassLoader 可以通过 class name 指定，使用起来更加方便</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader -c 1c1582d6</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227195601884.png" alt="" /></p><p>（5）使用 ClassLoader 去查找指定资源 resource 所在的位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader -c 1c1582d6 -r META-INF/MANIFEST.MF</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227195726132.png" alt="" /></p><p>（6）使用 ClassLoader 去加载类</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader -c 5c647e05 --load demo.MathGame</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201227195937705.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-前言&quot;&gt;&lt;/a&gt; 一、前言&lt;/h2&gt;
&lt;p&gt;在本章节中，将学习以下 Arthas 的 Class 相关命令，同时我也会附上官方文档的链接，方便大家查阅：&lt;/p&gt;
&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    <category term="Java" scheme="https://jitwxs.cn/categories/Java/"/>
    
    <category term="性能分析" scheme="https://jitwxs.cn/categories/Java/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Arthas" scheme="https://jitwxs.cn/tags/Arthas/"/>
    
  </entry>
  
  <entry>
    <title>Arthas 初探（3）——JVM 命令</title>
    <link href="https://jitwxs.cn/e88e6355.html"/>
    <id>https://jitwxs.cn/e88e6355.html</id>
    <published>2020-12-26T12:28:17.000Z</published>
    <updated>2020-12-27T11:43:18.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言"></a> 一、前言</h2><p>在本章节中，将学习以下 Arthas 的 JVM 相关命令，同时我也会附上官方文档的链接，方便大家查阅：</p><ul><li><a href="https://arthas.aliyun.com/doc/dashboard.html">dashboard</a> 仪表板，可以显示：线程，内存，堆栈，GC，Runtime 等信息</li><li><a href="https://arthas.aliyun.com/doc/thread.html">thread</a> 显示线程的堆栈</li><li><a href="https://arthas.aliyun.com/doc/jvm.html">jvm</a> 显示 JAVA 虚拟机信息</li><li><a href="https://arthas.aliyun.com/doc/sysprop.html">sysprop</a> 显示 JVM 中系统属性，也可以修改某个属性</li><li><a href="https://arthas.aliyun.com/doc/sysenv.html">sysenv</a> 显示 JVM 中系统环境变量配置信息</li><li><a href="https://arthas.aliyun.com/doc/vmoption.html">vmoption</a> 显示 JVM 中选项信息</li><li><a href="https://arthas.aliyun.com/doc/getstatic.html">getstatic</a> 获取类中静态成员变量</li><li><a href="https://arthas.aliyun.com/doc/ognl.html">ognl</a> 执行一条 ognl 表达式，对象图导航语言</li></ul><h2 id="二-dashboard"><a class="markdownIt-Anchor" href="#二-dashboard"></a> 二、dashboard</h2><p>显示当前系统的实时数据面板，按 <code>q</code> 或 <code>ctrl+c</code> 退出。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226194318.png" alt="" /></p><h3 id="21-数据说明"><a class="markdownIt-Anchor" href="#21-数据说明"></a> 2.1 数据说明</h3><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>ID</td><td>Java 级别的线程ID，注意这个 ID 不能跟 jstack 中的 nativeID 一一对应</td></tr><tr><td>NAME</td><td>线程名</td></tr><tr><td>GROUP</td><td>线程组名</td></tr><tr><td>PRIORITY</td><td>线程优先级, 1~10之间的数字，越大表示优先级越高</td></tr><tr><td>STATE</td><td>线程的状态</td></tr><tr><td>%CPU</td><td>线程消耗的 CPU 占比，采样 100ms，将所有线程在这 100ms 内的 CPU 使用量求和，再算出每个线程的 CPU 使用占比。</td></tr><tr><td>DELTA_TIME</td><td>上次采样之后线程运行增量CPU时间，数据格式为<code>秒</code></td></tr><tr><td>TIME</td><td>线程运行总时间，数据格式为<code>分：秒</code></td></tr><tr><td>INTERRUPTED</td><td>线程当前的中断位状态</td></tr><tr><td>DAEMON</td><td>是否是守护线程</td></tr></tbody></table><h3 id="22-内部线程"><a class="markdownIt-Anchor" href="#22-内部线程"></a> 2.2 内部线程</h3><p>在使用 <code>dastboard</code> 或者 <code>thread</code> 命令时，会看到有些线程的 ID 为 -1。这是在 Java 8 之后支持观测 JVM 的内部线程。</p><p>这些内部线程只有名称和 CPU 时间，没有 ID 及状态等信息。 通过内部线程可以观测到 JVM 活动，如 GC、JIT 编译等占用 CPU 情况，方便了解 JVM 整体运行状况。</p><p>JVM内部线程包括下面几种：</p><ul><li>JIT 编译线程：<code>C1 CompilerThread0</code>, <code>C2 CompilerThread0</code> 等</li><li>GC 线程：<code>GC Thread0</code>, <code>G1 Young RemSet Sampling</code> 等</li><li>其它内部线程：<code>VM Periodic Task Thread</code>, <code>VM Thread</code>, <code>Service Thread</code> 等</li></ul><p>当 JVM 堆(heap)/元数据(metaspace)空间不足或 OOM 时，可以看到 GC 线程的 CPU 占用率明显高于其他的线程。</p><p>当执行 <code>trace/watch/tt/redefine</code> 等命令后，可以看到 JIT 线程活动变得更频繁。因为 JVM 热更新 class 字节码时清除了此 class 相关的 JIT 编译结果，需要重新编译。</p><h2 id="三-thread"><a class="markdownIt-Anchor" href="#三-thread"></a> 三、thread</h2><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>id</em></td><td>线程 ID</td></tr><tr><td>[n:]</td><td>指定最忙的前 N 个线程并打印堆栈</td></tr><tr><td>[b]</td><td>找出当前阻塞其他线程的线程</td></tr><tr><td>[i <code>&lt;value&gt;</code>]</td><td>指定 CPU 使用率统计的采样间隔，单位为毫秒，默认值为 200</td></tr><tr><td>[–all]</td><td>显示所有匹配的线程</td></tr></tbody></table><h3 id="31-cpu-使用率"><a class="markdownIt-Anchor" href="#31-cpu-使用率"></a> 3.1 CPU 使用率</h3><p>这里的 CPU 使用率与 Linux 命令 <code>top -H -p &lt;pid&gt;</code> 的线程 <code>%CPU</code> 类似，一段采样间隔时间内，当前 JVM 里各个线程的增量 CPU 时间与采样间隔时间的比例。</p><p>工作原理如下：</p><p>（1）首先第一次采样，获取所有线程的CPU时间（调用的是<code>java.lang.management.ThreadMXBean#getThreadCpuTime()</code>及<code>sun.management.HotspotThreadMBean.getInternalThreadCpuTimes()</code>接口）</p><p>（2）然后睡眠等待一个间隔时间（默认为 200ms，可以通过 <code>-i</code> 指定间隔时间）</p><p>（3）再次第二次采样，获取所有线程的 CPU 时间，对比两次采样数据，计算出每个线程的增量CPU 时间</p><p>（4）计算得到 CPU 使用率</p><blockquote><p>线程 CPU 使用率 = 线程增量 CPU 时间 / 采样间隔时间 * 100%</p></blockquote><p>注意： 这个统计也会产生一定的开销（JDK 这个接口本身开销比较大），因此会看到 as 的线程占用一定的百分比，为了降低统计自身的开销带来的影响，可以把采样间隔拉长一些，比如 5000 毫秒。</p><h3 id="32-展示当前最忙的-n-个线程"><a class="markdownIt-Anchor" href="#32-展示当前最忙的-n-个线程"></a> 3.2 展示当前最忙的 N 个线程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread -n 3</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226205037.png" alt="" /></p><ul><li><p>如果没有进程 ID，且包含<code>[Internal]</code>表示这是 JVM 内部线程，和 dashboard 命令中相同。</p></li><li><p><code>cpuUsage</code> 为采样间隔时间内线程的 CPU 使用率，和 dashboard 命令中相同。</p></li><li><p><code>deltaTime</code>为采样间隔时间内线程的增量 CPU 时间，小于 1ms 时被取整显示为 0ms。</p></li><li><p><code>time</code> 线程运行总CPU时间。</p></li></ul><h3 id="33-显示第一页线程"><a class="markdownIt-Anchor" href="#33-显示第一页线程"></a> 3.3 显示第一页线程</h3><p>默认按照 CPU 增量时间降序排列，只显示第一页数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread</span><br></pre></td></tr></table></figure><h3 id="34-显示所有线程"><a class="markdownIt-Anchor" href="#34-显示所有线程"></a> 3.4 显示所有线程</h3><p>有时需要获取全部JVM的线程数据进行分析，可以一次全部展示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread -all</span><br></pre></td></tr></table></figure><h3 id="35-显示单个线程运行堆栈"><a class="markdownIt-Anchor" href="#35-显示单个线程运行堆栈"></a> 3.5 显示单个线程运行堆栈</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread &lt;pid&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226205725.png" alt="" /></p><h3 id="36-找出当前阻塞其他线程的线程"><a class="markdownIt-Anchor" href="#36-找出当前阻塞其他线程的线程"></a> 3.6 找出当前阻塞其他线程的线程</h3><p>有时候我们发现应用卡住了， 通常是由于某个线程拿住了某个锁， 并且其他线程都在等待这把锁造成的（即死锁），使用该命令可以一键找出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread -b</span><br></pre></td></tr></table></figure><blockquote><p>注意：3.4.5 版本目前只支持找出synchronized关键字阻塞住的线程， 如果是<code>java.util.concurrent.Lock</code>， 目前还不支持。</p></blockquote><h3 id="37-指定采样间隔"><a class="markdownIt-Anchor" href="#37-指定采样间隔"></a> 3.7 指定采样间隔</h3><ul><li><code>thread -i 1000</code> : 统计最近 1000ms 内的线程 CPU 时间</li><li><code>thread -n 3 -i 1000</code> : 列出 1000ms 内最忙的 3 个线程栈</li></ul><h3 id="38-指定状态所有线程"><a class="markdownIt-Anchor" href="#38-指定状态所有线程"></a> 3.8 指定状态所有线程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread –state &lt;state&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226210136.png" alt="" /></p><h2 id="四-jvm"><a class="markdownIt-Anchor" href="#四-jvm"></a> 四、JVM</h2><p>查看当前 JVM 的信息</p><h4 id="41-thread-相关"><a class="markdownIt-Anchor" href="#41-thread-相关"></a> 4.1 Thread 相关</h4><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>COUNT</td><td>JVM 当前活跃的线程数</td></tr><tr><td>DAEMON-COUNT</td><td>JVM 当前活跃的守护线程数</td></tr><tr><td>PEAK-COUNT</td><td>从 JVM 启动开始曾经活着的最大线程数</td></tr><tr><td>STARTED-COUNT</td><td>从 JVM 启动开始总共启动过的线程次数</td></tr><tr><td>DEADLOCK-COUNT</td><td>JVM 当前死锁的线程数</td></tr></tbody></table><h4 id="42-文件描述符相关"><a class="markdownIt-Anchor" href="#42-文件描述符相关"></a> 4.2 文件描述符相关</h4><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>MAX-FILE-DESCRIPTOR-COUNT</td><td>JVM 进程最大可以打开的文件描述符数</td></tr><tr><td>OPEN-FILE-DESCRIPTOR-COUNT</td><td>JVM 当前打开的文件描述符数</td></tr></tbody></table><h2 id="五-sysprop"><a class="markdownIt-Anchor" href="#五-sysprop"></a> 五、sysprop</h2><p>即 System Property，查看和修改 JVM 的系统属性。</p><p>（1）查看所有属性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysprop</span><br></pre></td></tr></table></figure><p>（2）查看单个属性（支持自动补全）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysprop &lt;key&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226211222.png" alt="" /></p><p>（3）修改单个属性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysprop &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226211538.png" alt="" /></p><h2 id="六-sysenv"><a class="markdownIt-Anchor" href="#六-sysenv"></a> 六、sysenv</h2><p>即 System Environment Variables，查看当前 JVM 的环境属性。</p><p>（1）查看所有环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysenv</span><br></pre></td></tr></table></figure><p>（2）查看单个环境变量（支持自动补全）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysenv &lt;key&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226211128.png" alt="" /></p><h2 id="七-vmoption"><a class="markdownIt-Anchor" href="#七-vmoption"></a> 七、vmoption</h2><p>查看、更新 VM 诊断相关的参数。</p><p>（1）查看所有选项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmoption</span><br></pre></td></tr></table></figure><p>（2）查看单个选项（支持自动补全）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmoption &lt;key&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226211401.png" alt="" /></p><p>3）修改单个选项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmoption &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226211422.png" alt="" /></p><h2 id="八-getstatic"><a class="markdownIt-Anchor" href="#八-getstatic"></a> 八、getstatic</h2><blockquote><p>推荐直接使用 ognl 命令，更加灵活</p></blockquote><p>通过 getstatic 命令可以方便的查看类的静态属性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getstatic &lt;class_name&gt; &lt;field_name&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226211746.png" alt="" /></p><h2 id="九-ognl"><a class="markdownIt-Anchor" href="#九-ognl"></a> 九、ognl</h2><p>自 3.0.5 起，Arthas 支持执行 OGNL 表达式。OGNL 的语法需要我们额外学习，<a href="http://commons.apache.org/proper/commons-ognl/language-guide.html">点击这里</a>查看详细文档。</p><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>express</em></td><td>执行的表达式</td></tr><tr><td><code>[c:]</code></td><td>执行表达式的 ClassLoader 的 hashcode，默认值是SystemClassLoader</td></tr><tr><td><code>[classLoaderClass:]</code></td><td>指定执行表达式的 ClassLoader 的 class name</td></tr><tr><td>[x]</td><td>结果对象的展开层次，默认值1</td></tr></tbody></table><p>（1）调用静态函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl &#x27;@java.lang.System@out.println(&quot;hello&quot;)&#x27;</span><br></pre></td></tr></table></figure><p>（2）调用静态函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl &#x27;@demo.MathGame@random&#x27;</span><br></pre></td></tr></table></figure><p>（3）执行多行表达式，赋值给临时变量，返回一个List</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl &#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226212342.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-前言&quot;&gt;&lt;/a&gt; 一、前言&lt;/h2&gt;
&lt;p&gt;在本章节中，将学习以下 Arthas 的 JVM 相关命令，同时我也会附上官方文档的链接，方便大家查阅：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="Java" scheme="https://jitwxs.cn/categories/Java/"/>
    
    <category term="性能分析" scheme="https://jitwxs.cn/categories/Java/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Arthas" scheme="https://jitwxs.cn/tags/Arthas/"/>
    
  </entry>
  
  <entry>
    <title>Arthas 初探（2）——基础命令</title>
    <link href="https://jitwxs.cn/85dcbb69.html"/>
    <id>https://jitwxs.cn/85dcbb69.html</id>
    <published>2020-12-26T12:00:34.000Z</published>
    <updated>2020-12-27T11:45:00.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言"></a> 一、前言</h2><p>在本章节中，将学习以下 Arthas 的基础命令，同时我也会附上官方文档的链接，方便大家查阅：</p><ul><li><a href="https://arthas.aliyun.com/doc/commands.html#arthas">help、cls、session、version、history、quit、stop</a></li><li><a href="https://arthas.aliyun.com/doc/cat.html">cat</a> 显示文本文件内容</li><li><a href="https://arthas.aliyun.com/doc/grep.html">grep</a> 对内容进行过滤，只显示关心的行</li><li><a href="https://arthas.aliyun.com/doc/pwd.html">pwd</a> 显示当前的工作路径</li><li><a href="https://arthas.aliyun.com/doc/reset.html">reset</a> 重置 arthas 增强的类</li><li><a href="https://arthas.aliyun.com/doc/keymap.html">keymap</a> 显示所有的快捷键</li></ul><h2 id="二-基础命令"><a class="markdownIt-Anchor" href="#二-基础命令"></a> 二、基础命令</h2><h3 id="21-help-cls-session-version-quit-stop"><a class="markdownIt-Anchor" href="#21-help-cls-session-version-quit-stop"></a> 2.1 help、cls、session、version、quit、stop</h3><p>（1）help</p><p>查看命令帮助信息。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226200828.png" alt="" /></p><p>（2）cls</p><p>清空当前屏幕区域。</p><p>（3）session</p><p>查看当前会话的信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@8452]$</span><span class="bash"> session</span></span><br><span class="line"> Name        Value</span><br><span class="line">--------------------------------------------------</span><br><span class="line"> JAVA_PID    8452</span><br><span class="line"> SESSION_ID  1434a3fe-8bbe-44ad-90d8-1a0bf2c7e461</span><br></pre></td></tr></table></figure><p>（4）version</p><p>输出当前目标 Java 进程所加载的 Arthas 版本号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@8452]$</span><span class="bash"> version</span></span><br><span class="line">3.4.5</span><br></pre></td></tr></table></figure><p>（5）history</p><p>打印命令历史。</p><p>（6）quit</p><p>退出当前 Arthas 客户端，其他 Arthas 客户端不受影响。</p><p>（7）stop</p><p>关闭 Arthas 服务端，所有 Arthas 客户端全部退出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@8452]$</span><span class="bash"> stop</span></span><br><span class="line">Resetting all enhanced classes ...</span><br><span class="line">Affect(class count: 0 , method count: 0) cost in 0 ms, listenerId: 0</span><br><span class="line">Arthas Server is going to shut down...</span><br><span class="line"><span class="meta">[arthas@8452]$</span><span class="bash"> session (1434a3fe-8bbe-44ad-90d8-1a0bf2c7e461) is closed because server is going to shutdown.</span></span><br></pre></td></tr></table></figure><h3 id="22-cat"><a class="markdownIt-Anchor" href="#22-cat"></a> 2.2 cat</h3><p>打印文件内容，类似于 Linux 中的 <code>cat</code> 命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@8452]$</span><span class="bash"> cat c:/Users/Jitwxs/Downloads/helloworld.txt</span></span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure><h3 id="23-grep"><a class="markdownIt-Anchor" href="#23-grep"></a> 2.3 grep</h3><p>匹配查找文件内容，类似于 Linux 中的 <code>grep</code> 命令，但它仅能用于管道命令。</p><table><thead><tr><th>参数列表</th><th>作用</th></tr></thead><tbody><tr><td>-n</td><td>显示行号</td></tr><tr><td>-i</td><td>忽略大小写查找</td></tr><tr><td>-m 行数</td><td>最大显示行数，要与查询字符串一起使用</td></tr><tr><td>-e “正则表达式”</td><td>使用正则表达式查找</td></tr></tbody></table><p>（1）只显示包含java字符串的行系统属性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@8452]$</span><span class="bash"> sysprop | grep java</span></span><br><span class="line"> java.specification.version      1.8</span><br><span class="line"> java.class.path                 arthas-demo.jar</span><br><span class="line"> java.vm.vendor                  Oracle Corporation</span><br><span class="line"> java.vendor.url                 http://java.oracle.com/</span><br><span class="line"> java.vm.specification.version   1.8</span><br><span class="line"> sun.java.launcher               SUN_STANDARD</span><br><span class="line"> sun.java.command                arthas-demo.jar</span><br><span class="line"> java.specification.vendor       Oracle Corporation</span><br><span class="line"> java.home                       D:\JAVA\JRE</span><br><span class="line"> java.vm.specification.vendor    Oracle Corporation</span><br><span class="line"> ....</span><br></pre></td></tr></table></figure><p>（2）显示包含java字符串的行和行号的系统属性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@8452]$</span><span class="bash"> sysprop | grep java -n</span></span><br><span class="line">6: java.specification.version      1.8</span><br><span class="line">9: java.class.path                 arthas-demo.jar</span><br><span class="line">10: java.vm.vendor                  Oracle Corporation</span><br><span class="line">13: java.vendor.url                 http://java.oracle.com/</span><br><span class="line">16: java.vm.specification.version   1.8</span><br><span class="line">18: sun.java.launcher               SUN_STANDARD</span><br><span class="line">20: sun.java.command                arthas-demo.jar</span><br><span class="line">25: java.specification.vendor       Oracle Corporation</span><br><span class="line">26: java.home                       D:\JAVA\JRE</span><br><span class="line">31: java.vm.specification.vendor    Oracle Corporation</span><br></pre></td></tr></table></figure><p>（3）显示包含system字符串的10行信息。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226201557.png" alt="" /></p><p>（4）使用正则表达式，显示包含2个o字符的线程信息。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226201641.png" alt="" /></p><h3 id="24-pwd"><a class="markdownIt-Anchor" href="#24-pwd"></a> 2.4 pwd</h3><p>返回当前的工作目录，类似于 Linux 中的 <code>pwd</code> 命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@8452]$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">C:\Users\Jitwxs\Downloads</span><br></pre></td></tr></table></figure><h3 id="25-reset"><a class="markdownIt-Anchor" href="#25-reset"></a> 2.5 reset</h3><p>重置增强类，将被 Arthas 增强过的类全部还原，Arthas 服务端关闭时会重置所有增强过的类。</p><p>（1）还原 Test 类</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reset Test</span><br></pre></td></tr></table></figure><p>（2）还原所有以 List 结尾的类</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reset *List</span><br></pre></td></tr></table></figure><p>（3）还原所有的类</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reset</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226202102.png" alt="" /></p><h3 id="26-keymap"><a class="markdownIt-Anchor" href="#26-keymap"></a> 2.6 keymap</h3><p>查看 Arthas 快捷键列表及自定义快捷键。</p><ul><li>任何时候 <code>tab</code> 键，会根据当前的输入给出提示</li><li>命令后敲 <code>-</code> 或 <code>--</code> ，然后按 <code>tab</code> 键，可以展示出此命令具体的选项</li></ul><table><thead><tr><th>快捷键说明</th><th>命令说明</th></tr></thead><tbody><tr><td>ctrl + a</td><td>跳到行首</td></tr><tr><td>ctrl + e</td><td>跳到行尾</td></tr><tr><td>ctrl + f</td><td>向前移动一个单词</td></tr><tr><td>ctrl + b</td><td>向后移动一个单词</td></tr><tr><td>键盘左方向键</td><td>光标向前移动一个字符</td></tr><tr><td>键盘右方向键</td><td>光标向后移动一个字符</td></tr><tr><td>键盘下方向键</td><td>下翻显示下一个命令</td></tr><tr><td>键盘上方向键</td><td>上翻显示上一个命令</td></tr><tr><td>ctrl + h</td><td>向后删除一个字符</td></tr><tr><td>ctrl + shift + /</td><td>向后删除一个字符</td></tr><tr><td>ctrl + u</td><td>撤销上一个命令，相当于清空当前行</td></tr><tr><td>ctrl + d</td><td>删除当前光标所在字符</td></tr><tr><td>ctrl + k</td><td>删除当前光标到行尾的所有字符</td></tr><tr><td>ctrl + i</td><td>自动补全，相当于敲<code>TAB</code></td></tr><tr><td>ctrl + j</td><td>结束当前行，相当于敲回车</td></tr><tr><td>ctrl + m</td><td>结束当前行，相当于敲回车</td></tr><tr><td>ctrl + c</td><td>终止当前命令</td></tr><tr><td>ctrl + z</td><td>挂起当前命令，后续可以 bg/fg 重新支持此命令，或 kill 掉</td></tr><tr><td>ctrl + a</td><td>回到行首</td></tr><tr><td>ctrl + e</td><td>回到行尾</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-前言&quot;&gt;&lt;/a&gt; 一、前言&lt;/h2&gt;
&lt;p&gt;在本章节中，将学习以下 Arthas 的基础命令，同时我也会附上官方文档的链接，方便大家查阅：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a hr</summary>
      
    
    
    
    <category term="Java" scheme="https://jitwxs.cn/categories/Java/"/>
    
    <category term="性能分析" scheme="https://jitwxs.cn/categories/Java/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Arthas" scheme="https://jitwxs.cn/tags/Arthas/"/>
    
  </entry>
  
  <entry>
    <title>Arthas 初探（1）——快速入门</title>
    <link href="https://jitwxs.cn/a64edcb1.html"/>
    <id>https://jitwxs.cn/a64edcb1.html</id>
    <published>2020-12-26T10:11:40.000Z</published>
    <updated>2020-12-26T13:52:06.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言"></a> 一、前言</h2><p>早就听闻阿里开源的 <code>Arthas</code> 在做 Java 应用诊断上十分牛逼，身边也有很多同事在使用，因此决定开一个坑，自己从零学习下这个工具的使用，本系列使用的版本是当前最新版 3.4.5。</p><p>由于 Arthas 经过这么长时间的发展，本身文档、在线教程已经十分健全了，同时还有第三方的 IDEA 插件、许多教学视频去帮助我们入门使用，因此这个系列的文章定位是个人笔记，而并非教程，希望不要误人子弟。</p><h2 id="二-概述"><a class="markdownIt-Anchor" href="#二-概述"></a> 二、概述</h2><blockquote><p><a href="https://arthas.aliyun.com">https://arthas.aliyun.com</a></p></blockquote><p>当你遇到以下类似问题而束手无策时，<code>Arthas</code>可以帮助你解决：</p><ol><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ol><p>使用 Arthas 需要 JDK 版本在 <strong>1.6 以上</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226184755.png" alt="" /></p><h2 id="三-快速安装"><a class="markdownIt-Anchor" href="#三-快速安装"></a> 三、快速安装</h2><blockquote><p><a href="https://arthas.aliyun.com/doc/install-detail.html">https://arthas.aliyun.com/doc/install-detail.html</a></p></blockquote><p>Arthas 本身也是个 Java 进程，得益于 Java 跨平台特性，所以我就直接在 Windows 上安装了。</p><p>（1）下载 Arthas 包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://arthas.aliyun.com/arthas-boot.jar</span><br></pre></td></tr></table></figure><p>（2）运行 Arthas</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是运行 Arthas 前至少保证系统正在运行一个 Java 进程，否则无法启动，并会报错：Can not find java process. Try to pass <pid> in command line.Please select an available pid。解决办法就是跑一个 Java 应用即可。</p></blockquote><p>如果需要卸载 Arthas 的话：</p><ul><li><p>在 Linux/Unix/Mac 平台，删除下面文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/.arthas/</span><br><span class="line">rm -rf ~/logs/arthas</span><br></pre></td></tr></table></figure></li><li><p>Windows平台直接删除user home下面的<code>.arthas</code>和<code>logs/arthas</code>目录</p></li></ul><h2 id="四-快速入门"><a class="markdownIt-Anchor" href="#四-快速入门"></a> 四、快速入门</h2><h3 id="41-attach-进程"><a class="markdownIt-Anchor" href="#41-attach-进程"></a> 4.1 attach 进程</h3><p>这里我们使用 Arthas 官方提供的 demo 包，这样我们就不需要自己编写代码了。将 demo 包下载下来并运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://arthas.aliyun.com/arthas-demo.jar</span><br><span class="line">java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p>这个 demo 功能是死循环做质因数分解，并记录下无法分解的次数，如下图所示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226192147.png" alt="" /></p><p>我们首先启动 Arthas 并 attach 上该进程。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226192318.png" alt="" /></p><blockquote><p>默认情况下，Arthas只listen 127.0.0.1，所以如果想从远程连接，则可以使用 <code>--target-ip</code>参数指定 listen 的IP</p></blockquote><p>另外如果条件允许的话，在 attach 后也可以使用浏览器登录，访问：<a href="http://127.0.0.1:3658">http://127.0.0.1:3658</a> 即可。也可以填入 IP，远程连接其他机器的 Arthas。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226192716.png" alt="20201226192716" /></p><h3 id="42-常用命令"><a class="markdownIt-Anchor" href="#42-常用命令"></a> 4.2 常用命令</h3><h4 id="421-dashboard"><a class="markdownIt-Anchor" href="#421-dashboard"></a> 4.2.1 dashboard</h4><blockquote><p><a href="https://arthas.aliyun.com/doc/dashboard.html">https://arthas.aliyun.com/doc/dashboard.html</a></p></blockquote><p>使用 <code>dastboard</code> 命令可以查看 Java 进程信息（定时刷新），如需退出使用 <code>q</code> 即可。它由如下四个部分组成：</p><ol><li>第一部分是显示JVM中运行的所有线程：所在线程组，优先级，线程的状态，CPU的占用率，是否是后台进程等</li><li>第二部分显示的JVM内存的使用情况</li><li>第三部分显示的是 GC 相关的信息</li><li>第四部分是操作系统的一些信息和Java版本号</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226194318.png" alt="" /></p><h4 id="422-thread"><a class="markdownIt-Anchor" href="#422-thread"></a> 4.2.2 thread</h4><blockquote><p><a href="https://arthas.aliyun.com/doc/thread.html">https://arthas.aliyun.com/doc/thread.html</a></p></blockquote><p>使用 <code>thread</code> 命令可以查看当前所有的线程信息。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226194023.png" alt="" /></p><p>并且可以通过追加 PID 的方式，查看具体某个线程的状态。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226194126.png" alt="" /></p><h4 id="423-jad"><a class="markdownIt-Anchor" href="#423-jad"></a> 4.2.3 jad</h4><blockquote><p><a href="https://arthas.aliyun.com/doc/jad.html">https://arthas.aliyun.com/doc/jad.html</a></p></blockquote><p>使用 <code>jad</code> 命令可以反编译 class 文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226194833.png" alt="" /></p><h4 id="422-watch"><a class="markdownIt-Anchor" href="#422-watch"></a> 4.2.2 watch</h4><blockquote><p><a href="https://arthas.aliyun.com/doc/watch.html">https://arthas.aliyun.com/doc/watch.html</a></p></blockquote><p><code>watch</code> 命令可以监控方法的入参出参：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226195701.png" alt="" /></p><h2 id="五-退出-arthas"><a class="markdownIt-Anchor" href="#五-退出-arthas"></a> 五、退出 Arthas</h2><p>如果只是退出当前的连接，可以用<code>quit</code>或者<code>exit</code>命令。Attach到目标进程上的 Arthas 还会继续运行，端口会保持开放，下次连接时可以直接连接上。</p><p>如果想完全退出arthas，可以执行<code>stop</code>命令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-前言&quot;&gt;&lt;/a&gt; 一、前言&lt;/h2&gt;
&lt;p&gt;早就听闻阿里开源的 &lt;code&gt;Arthas&lt;/code&gt; 在做 Java 应用诊断上十分牛逼，身边也有很多同事在使用，因此决定开一</summary>
      
    
    
    
    <category term="Java" scheme="https://jitwxs.cn/categories/Java/"/>
    
    <category term="性能分析" scheme="https://jitwxs.cn/categories/Java/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Arthas" scheme="https://jitwxs.cn/tags/Arthas/"/>
    
  </entry>
  
  <entry>
    <title>详解 JDK 常用监控工具</title>
    <link href="https://jitwxs.cn/c72fb74.html"/>
    <id>https://jitwxs.cn/c72fb74.html</id>
    <published>2020-12-26T06:23:54.000Z</published>
    <updated>2020-12-26T13:52:06.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-jvm-参数"><a class="markdownIt-Anchor" href="#一-jvm-参数"></a> 一、JVM 参数</h2><p>JVM 参数类型主要分为标准参数、X 参数、XX 参数三类。</p><p>（1）对于标准参数，在 JVM 的各个版本中基本是不变的，相对是比较稳定的。例如 <code>-help</code>、<code>-version</code>、<code>-server</code>、<code>-client</code> 等。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226151819.png" alt="" /></p><p>（2）X 参数是非标准化参数，在不同的 JVM 版本中可能会发生变化。例如：</p><ul><li><code>-Xint</code>：完全解释执行，不编译成本地代码</li><li><code>-Xcomp</code>：第一次使用就编译成本地代码</li><li><code>-Xmixed</code>：混合模式，JVM自行决定是否编译成本地代码（默认模式）</li></ul><p>（3）XX 参数是我们使用最为经常的参数，它也是非标准化参数，主要用于 JVM 调优和 Debug。它分为 Boolean 类型和键值对类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Boolean 类型</span><br><span class="line">格式：-XX:[+-]&lt;name&gt; 表示启用或禁用 name 属性</span><br><span class="line">例如：-XX:+UseConcMarkSweepGC</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">键值对类型</span><br><span class="line">格式：-XX:&lt;name&gt;&#x3D;&lt;value&gt; 表示 name 属性的值是 value</span><br><span class="line">例如：-XX:MaxGCPauseMillis&#x3D;500</span><br></pre></td></tr></table></figure><p>各大 JVM 的相关参数可以到这个网站去查询：<a href="https://chriswhocodes.com/hotspot_options_jdk8.html">https://chriswhocodes.com/hotspot_options_jdk8.html</a></p><h2 id="二-jps"><a class="markdownIt-Anchor" href="#二-jps"></a> 二、JPS</h2><p><code>JPS</code> 类似于 Linux 系统中的 PS 命令，只是它是专门用来查看 Java 进程的 PID，<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jps.html">点击这里</a>查看官方文档。</p><p>使用 <code>jps -l</code> 可以获取 Java 进程的包名，例如我启动了一个 SpringBoot 项目，使用该命令后可以拿到它的 PID 是 3007。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226152703.png" alt="" /></p><h2 id="三-jinfo"><a class="markdownIt-Anchor" href="#三-jinfo"></a> 三、JINFO</h2><p><code>JINFO</code> 命令可以查看 Java 进程的 JVM 参数，<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jinfo.html">点击这里</a>查看官方文档。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flag &lt;name&gt; &lt;pid&gt; 查看进程的某一个 JVM 参数</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226152856.png" alt="" /></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flags &lt;pid&gt; 查看进程所有非默认的 JVM 参数</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226153147.png" alt="" /></p><h2 id="四-jstat"><a class="markdownIt-Anchor" href="#四-jstat"></a> 四、JSTAT</h2><p><code>jstat</code> 可以查看 JVM 的统计信息（类加载、垃圾收集、JIT 编译等），<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html">点击这里</a>查看官方文档。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：jstat -class &lt;pid&gt; &lt;interval&gt; &lt;count&gt; 每隔 Interval 毫秒查看一次进程的类加载信息，查看 count 次</span><br><span class="line">例如：jstat -class 3007 1000 5</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226153636.png" alt="查看类加载信息" /></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：jstat -gc &lt;pid&gt; &lt;interval&gt; &lt;count&gt; 每隔 Interval 毫秒查看一次进程的 GC 信息，查看 count 次</span><br><span class="line">例如：jstat -gc 3007 1000 2</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226153918.png" alt="查看GC(1.8)信息" /></p><ul><li>S0C、S1C、S0U、S1U：S0 和 S1 的总量与使用量</li><li>EC、EU：Eden 区总量与使用量</li><li>OC、OU：Old 区总量与使用量</li><li>MC、MU：Metaspace 区总量与使用量</li><li>CCSC、CCSU：压缩类空间总量与使用量</li><li>YGC、YGCT：YoungGC 的次数与时间</li><li>FGC、FGCT：FullGC 的次数与时间</li><li>GCT：总的 GC 时间</li></ul><blockquote><p>除了列出的 -gc 外，还有 -gccapactly、-gccause、-gcnew、-gcold 等</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：jstat -compiler &lt;pid&gt; 查看进程 JIT 编译信息</span><br><span class="line">例如：jstat -compiler 3007</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226155912.png" alt="" /></p><ul><li>Compiled、Failed、Invalid 将代码编译成本地方法的成功、失败、无效任务量</li><li>FailedType、FailedMethod 上次编译失败的类型和方法名</li></ul><h2 id="五-jmap"><a class="markdownIt-Anchor" href="#五-jmap"></a> 五、JMAP</h2><p><code>jmap</code> 命令可以帮助我们获取 Java 进程的内存快照，并可以将其导入到 <a href="https://www.eclipse.org/mat/downloads.php">MAT</a>（免费）或 <a href="https://www.ej-technologies.com/products/jprofiler/overview.html">JProfile</a>（付费）等工具中去做内存分析。这边的内容我在 <a href="/f4adeb1d.html">《首次排查 OOM 实录》</a> 这篇文章中提到了，就不再赘述了。</p><h2 id="六-jstack"><a class="markdownIt-Anchor" href="#六-jstack"></a> 六、JSTACK</h2><p><code>jstack</code> 命令可以帮助我们获取 Java 进程中的线程快照，<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstack.html">点击这里</a>查看官方文档。</p><p>进程状态一般有以下几种（<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr034.html%EF%BC%89%EF%BC%9A">https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr034.html）：</a></p><table><thead><tr><th>Thread State</th><th>Description</th></tr></thead><tbody><tr><td>NEW</td><td>线程未启动</td></tr><tr><td>RUNNABLE</td><td>线程已在 JVM 中运行</td></tr><tr><td>BLOCKED</td><td>线程处于阻塞状态等待锁</td></tr><tr><td>WAITING</td><td>线程无限期地等待另一个线程执行特定操作</td></tr><tr><td>TIMED_WAITING</td><td>WAITING 状态加上超时时间</td></tr><tr><td>TERMINATED</td><td>线程已经退出</td></tr></tbody></table><p>例如当我们发现 CPU 的利用率飙高，就需要使用 jstack 查看下线程的状态了，一般的操作流程是这样的：</p><p>（1）<code>jps -l</code> 获取到需要分析的 Java 进程的 PID。【本例中为 3007】</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226152703.png" alt="" /></p><p>（2）<code>top -Hp &lt;PID&gt;</code> 查看该 Java 进程内部每个线程的 CPU 和占用情况，找到你觉得有问题的那一个线程的 PID，转成十六进制记录下来。【我这个程序只是个 helloword，所以我就随便找一个线程了。比如取 3018，它的十六进制是 0xbca】</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226164440.png" alt="" /></p><p>（3）<code>jstack &lt;PID&gt; &lt;filename&gt;</code> 获取到线程快照。【本例中输出为 a.out】</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226164611.png" alt="" /></p><p>（4）然后在其中搜索你觉得有问题的那个进程 ID。【例子举得不好，找的线程是 GC 线程，知道是这么个流程就行】</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201226164652.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-jvm-参数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-jvm-参数&quot;&gt;&lt;/a&gt; 一、JVM 参数&lt;/h2&gt;
&lt;p&gt;JVM 参数类型主要分为标准参数、X 参数、XX 参数三类。&lt;/p&gt;
&lt;p&gt;（1）对于标准参数，在 JVM </summary>
      
    
    
    
    <category term="Java" scheme="https://jitwxs.cn/categories/Java/"/>
    
    <category term="性能分析" scheme="https://jitwxs.cn/categories/Java/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
    
    <category term="JVM" scheme="https://jitwxs.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>解决 JVM 异常栈丢失问题</title>
    <link href="https://jitwxs.cn/f8cb808a.html"/>
    <id>https://jitwxs.cn/f8cb808a.html</id>
    <published>2020-12-19T14:13:44.000Z</published>
    <updated>2020-12-26T13:52:06.965Z</updated>
    
    <content type="html"><![CDATA[<p>JVM 默认情况下，当代码的某一个位置高频率抛出同一异常时，为了节约性能，JVM 会对以下异常类型的异常栈进行优化，不再打印完整异常栈。</p><ul><li>NullPointerException</li><li>ArithmeticException</li><li>ArrayIndexOutOfBoundsException</li><li>ArrayStoreException</li><li>ClassCastException</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201219221754.png" alt="" /></p><p>往往出现这种情况，只能期望找到最初报错的日志，去找到具体的异常行。</p><p>除此之外，我们可以通过指定 <code>OmitStackTraceInFastThrow</code> 这个 JVM 参数去关掉这个优化，仅需要在应用启动参数中添加如下即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-OmitStackTraceInFastThrow</span><br></pre></td></tr></table></figure><blockquote><p>这个参数对于大部分类型的 JVM 都是适用的，已在 HotSpot 和 Zing上验证可行，可以<a href="https://chriswhocodes.com/zing_jdk8_options.html">点击这里</a>查询各厂商 JVM 参数列表。</p></blockquote><p>在 IDEA 中的话，配置如下即可：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201219222602.png" alt="" /></p><p>另外需要注意的是，不加控制的打印异常栈，对 CPU 和内存都会有影响。最好在出现异常后尽快解决，或对异常打印增加频率控制。总之就是这个思想，懂就行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JVM 默认情况下，当代码的某一个位置高频率抛出同一异常时，为了节约性能，JVM 会对以下异常类型的异常栈进行优化，不再打印完整异常栈。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NullPointerException&lt;/li&gt;
&lt;li&gt;ArithmeticException&lt;/li&gt;
</summary>
      
    
    
    
    <category term="Java" scheme="https://jitwxs.cn/categories/Java/"/>
    
    
    <category term="JVM" scheme="https://jitwxs.cn/tags/JVM/"/>
    
    <category term="OmitStackTraceInFastThrow" scheme="https://jitwxs.cn/tags/OmitStackTraceInFastThrow/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发编程——CompletableFuture</title>
    <link href="https://jitwxs.cn/d00bfcd.html"/>
    <id>https://jitwxs.cn/d00bfcd.html</id>
    <published>2020-12-12T10:10:44.000Z</published>
    <updated>2020-12-26T13:52:06.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言"></a> 一、前言</h2><p>本文向大家安利一下 JDK 8 中的并发工具类 <code>CompletableFuture</code>，利用它可以方便的进行并发、异步的流式、协调操作。自从用了它，一下次就不想用 CountdownLatch 和 Future 了，赶紧一起来了解下吧。</p><h2 id="二-实例化"><a class="markdownIt-Anchor" href="#二-实例化"></a> 二、实例化</h2><p>CompletableFuture 提供了两组静态方法来实例化出对象，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(Runnable runnable);</span><br><span class="line">CompletableFuture.runAsync(Runnable runnable, Executor executor);</span><br><span class="line"></span><br><span class="line">CompletableFuture.supplyAsync(Supplier&lt;U&gt; supplier);</span><br><span class="line">CompletableFuture.supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</span><br></pre></td></tr></table></figure><ul><li><code>runAsync()</code> 方法接收的是 Runnable 实例，用于异步任务不需要返回值的情况</li><li><code>supplyAsync()</code> 方法接受的是 Supplier 实例，用于余部任务需要返回值的情况</li><li>这两组方法同时提供了 Executor 参数的重载，用于指定线程池来执行。如果不指定，则使用默认的 <code>ForkJoinPool.commonPool()</code> 线程池，类型与 parallelStream。</li></ul><h2 id="三-流式计算"><a class="markdownIt-Anchor" href="#三-流式计算"></a> 三、流式计算</h2><p>利用 CompletableFuture ，可以实现流式计算，即当任务 A 执行完毕后，在执行任务 B。</p><p>这里根据业务不同变种很多，例如 任务 A 需不需要有返回值，任务 B 需不要参数，以及任务 B 自身需不需要返回值等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(() -&gt; &#123;&#125;).thenRun(() -&gt; &#123;&#125;); </span><br><span class="line">CompletableFuture.runAsync(() -&gt; &#123;&#125;).thenAccept(resultA -&gt; &#123;&#125;); </span><br><span class="line">CompletableFuture.runAsync(() -&gt; &#123;&#125;).thenApply(resultA -&gt; <span class="string">&quot;resultB&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面三行代码演示的是任务 A 没有返回值的情况，即 <code>runAsync()</code>：</p><ul><li><code>thenRun()</code>：任务 B 在任务 A 执行完毕后执行，任务 B 无需参数也无返回值。</li><li><code>thenAccept()</code>：任务 B 在任务 A 执行完毕后执行，任务 B 需要任务 A 的返回结果作为参数，任务 B 无需返回值。（实际上此处任务B的参数一定为 null，因为任务 A 无返回值）</li><li><code>thenApply()</code>：任务 B 在任务 A 执行完毕后执行，任务 B 需要任务 A 的返回结果作为参数，任务 B 自身也有返回值。实际上此处任务B的参数一定为 null，因为任务 A 无返回值）</li></ul><blockquote><p><code>thenRun()</code> 、<code>thenAccept()</code>、<code>thenApply()</code> 也有对应的带 Async 后缀的方法，需要注意的是，并不是说带 Async 就是异步，不带就是同步的意思。而是说带 Async 会被重新放进线程池，由线程池决定何时执行；不带 Async 就会仍然由当前线程执行，不再重新放入线程池中。</p></blockquote><p>对应的，下面三行代码演示的是任务 A 有返回值的情况，即 <code>supplyAsync()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenRun(() -&gt; &#123;&#125;);</span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenAccept(resultA -&gt; &#123;&#125;);</span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenApply(resultA -&gt; resultA + <span class="string">&quot; resultB&quot;</span>);</span><br></pre></td></tr></table></figure><p>另外不一定只有任务 A、任务 B，只要业务需要，后面也许还有任务 C、任务 D…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Executor executor = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        IntStream.range(<span class="number">1</span>, <span class="number">10</span>).boxed()</span><br><span class="line">                .forEach(e -&gt; CompletableFuture.supplyAsync(() -&gt; pow3(e), executor)</span><br><span class="line">                        .thenApplyAsync(CompletableFutureTest::sqrt, executor)</span><br><span class="line">                        .thenAcceptAsync(CompletableFutureTest::print));</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">pow3</span><span class="params">(<span class="keyword">double</span> input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.pow(input, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> input)</span> </span>&#123;</span><br><span class="line">        System.out.println(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码举了个例子，任务 A 负责计算输入值的三次方，任务 B 负责计算输入值的开根号，任务 C 负责打印输出值。</p><p>程序运行结果如下：（请忽略没有按照 1 ~ 10 的先后顺序输出的问题）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="number">5.196152422706632</span></span><br><span class="line"><span class="number">22.627416997969522</span></span><br><span class="line"><span class="number">18.520259177452136</span></span><br><span class="line"><span class="number">8.0</span></span><br><span class="line"><span class="number">2.8284271247461903</span></span><br><span class="line"><span class="number">11.180339887498949</span></span><br><span class="line"><span class="number">14.696938456699069</span></span><br><span class="line"><span class="number">27.0</span></span><br></pre></td></tr></table></figure><h2 id="四-异常处理"><a class="markdownIt-Anchor" href="#四-异常处理"></a> 四、异常处理</h2><p>CompletableFuture 提供了 <code>exceptionally()</code> 和 <code>handle()</code> 方法来进行异常处理，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">exceptionally</span><span class="params">(Function&lt;Throwable, ? extends T&gt; fn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">handle</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn)</span></span>;</span><br></pre></td></tr></table></figure><p>CompletableFuture 某个任务执行抛出异常，是不会被被抛出到外部来的，同时会影响后续的任务执行。以上一节最后代码为例，我们修改 <code>pow3()</code> 代码，让其抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">pow3</span><span class="params">(<span class="keyword">double</span> input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    <span class="comment">// return Math.pow(input, 3);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行程序后，控制台没有打印任何异常日志，同时后续任务也终止执行了。</p><h3 id="41-exceptionally"><a class="markdownIt-Anchor" href="#41-exceptionally"></a> 4.1 exceptionally</h3><p>使用 <code>exceptionally()</code> ，可以当任务内部出现异常时，自行做业务处理，并返回新的结果，并传递给后续任务。</p><p>修改我们的例子，main() 方法中代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">10</span>).boxed()</span><br><span class="line">    .forEach(e -&gt; CompletableFuture.supplyAsync(() -&gt; pow3(e), executor)</span><br><span class="line">            .exceptionally(ex -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;pow3() function exception:&quot;</span> + ex.getMessage());</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0D</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">            .thenApplyAsync(CompletableFutureTest::sqrt, executor)</span><br><span class="line">            .thenAcceptAsync(CompletableFutureTest::print));</span><br></pre></td></tr></table></figure><p>重新运行后输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pow3() function exception:java.lang.IllegalArgumentException: xxx</span><br><span class="line">pow3() function exception:java.lang.IllegalArgumentException: xxx</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="number">1.0</span></span><br><span class="line">pow3() function exception:java.lang.IllegalArgumentException: xxx</span><br><span class="line">pow3() function exception:java.lang.IllegalArgumentException: xxx</span><br><span class="line">pow3() function exception:java.lang.IllegalArgumentException: xxx</span><br><span class="line">pow3() function exception:java.lang.IllegalArgumentException: xxx</span><br><span class="line">pow3() function exception:java.lang.IllegalArgumentException: xxx</span><br><span class="line">pow3() function exception:java.lang.IllegalArgumentException: xxx</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="number">1.0</span></span><br><span class="line">pow3() function exception:java.lang.IllegalArgumentException: xxx</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="number">1.0</span></span><br></pre></td></tr></table></figure><h3 id="42-handle"><a class="markdownIt-Anchor" href="#42-handle"></a> 4.2 handle</h3><p>除了使用 exceptionally 外，<code>handle()</code> 也可以用于处理异常，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">10</span>).boxed()</span><br><span class="line">    .forEach(e -&gt; CompletableFuture.supplyAsync(() -&gt; pow3(e), executor)</span><br><span class="line">            .handle((result, ex) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;pow3() function exception:&quot;</span> + ex.getMessage());</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1.0D</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .thenApplyAsync(CompletableFutureTest::sqrt, executor)</span><br><span class="line">            .thenAcceptAsync(CompletableFutureTest::print));</span><br></pre></td></tr></table></figure><p><code>handle()</code> 方法存在有两个参数，参数1为任务本身的返回结果，参数2为任务内抛出的异常。这两个参数至少有一个必然为 null，因此可以通过判断 ex 是否为 null 进行异常处理。</p><blockquote><p>当然这两个参数也可以都为 null，因为你可以让任务返回 null。</p></blockquote><h2 id="五-栅栏"><a class="markdownIt-Anchor" href="#五-栅栏"></a> 五、栅栏</h2><p>栅栏需求在实际开发中十分普遍，例如：</p><ul><li>存在任务 A，需要异步处理，所有线程处理完毕后，再做其他业务处理</li><li>存在任务 A、任务 B、任务 C，任务 A 和 任务 B 可以并行执行，但是必须 任务 A 和 任务 B 全部执行完毕后才能执行任务 C</li></ul><p>以往实现这些需求时候，我们会使用 CountdownLatch 和 Future，现在可以多一个选择了。</p><h3 id="51-两个任务的栅栏"><a class="markdownIt-Anchor" href="#51-两个任务的栅栏"></a> 5.1 两个任务的栅栏</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; cfA = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; cfB = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultB&quot;</span>);</span><br><span class="line"></span><br><span class="line">cfA.thenAcceptBoth(cfB, (resultA, resultB) -&gt; &#123;&#125;);</span><br><span class="line">cfA.thenCombine(cfB, (resultA, resultB) -&gt; <span class="string">&quot;result A + B&quot;</span>);</span><br><span class="line">cfA.runAfterBoth(cfB, () -&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码介绍了如何实现任务 A 和任务 B 的并行执行：</p><ul><li><code>thenAcceptBoth()</code>：并行执行，需要两个任务的结果作为参数，进行后续处理，无返回值。</li><li><code>thenCombine()</code>：并行执行，需要两个任务的结果作为参数，进行后续处理，有返回值。</li><li><code>runAfterBoth()</code>：并行执行，不需要两个任务的结果作为参数，进行后续处理，无返回值。</li></ul><p>下面的程序演示了数字 1 ~ 10 并行进行开根号和三次方计算，并在完成这二者计算后输出结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Executor executor = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        IntStream.range(<span class="number">1</span>, <span class="number">10</span>).boxed()</span><br><span class="line">                .forEach(e -&gt; CompletableFuture.supplyAsync(() -&gt; pow3(e), executor)</span><br><span class="line">                        .thenAcceptBoth(CompletableFuture.supplyAsync(() -&gt; sqrt(e), executor), (resultA, resultB) -&gt; System.out.println(<span class="string">&quot;resultA:&quot;</span> + resultA + <span class="string">&quot;, resultB:&quot;</span> + resultB)));</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">pow3</span><span class="params">(<span class="keyword">double</span> input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.pow(input, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resultA:<span class="number">1.0</span>, resultB:<span class="number">1.0</span></span><br><span class="line">resultA:<span class="number">8.0</span>, resultB:<span class="number">1.4142135623730951</span></span><br><span class="line">resultA:<span class="number">27.0</span>, resultB:<span class="number">1.7320508075688772</span></span><br><span class="line">resultA:<span class="number">343.0</span>, resultB:<span class="number">2.6457513110645907</span></span><br><span class="line">resultA:<span class="number">125.0</span>, resultB:<span class="number">2.23606797749979</span></span><br><span class="line">resultA:<span class="number">216.0</span>, resultB:<span class="number">2.449489742783178</span></span><br><span class="line">resultA:<span class="number">64.0</span>, resultB:<span class="number">2.0</span></span><br><span class="line">resultA:<span class="number">729.0</span>, resultB:<span class="number">3.0</span></span><br><span class="line">resultA:<span class="number">512.0</span>, resultB:<span class="number">2.8284271247461903</span></span><br></pre></td></tr></table></figure><h3 id="52-多个任务的栅栏"><a class="markdownIt-Anchor" href="#52-多个任务的栅栏"></a> 5.2 多个任务的栅栏</h3><p>上一小节介绍的仅适用于两个任务之间的并行计算，如果我们想要实现更多任务的并行计算，CompletableFuture 也为我们提供了 <code>allOf()</code> 和 <code>anyOf()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="521-allof"><a class="markdownIt-Anchor" href="#521-allof"></a> 5.2.1 allOf</h4><p>下面代码介绍了 <code>allOf()</code> 的用法，它聚合了多个任务，并通过 <code>join()</code> 方法进行阻塞等待。需要注意的是，该方法是没有返回值的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture cfA = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>);</span><br><span class="line">CompletableFuture cfB = CompletableFuture.supplyAsync(() -&gt; <span class="number">123</span>);</span><br><span class="line">CompletableFuture cfC = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultC&quot;</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.allOf(cfA, cfB, cfC);</span><br><span class="line"><span class="comment">// 所以这里的 join() 将阻塞，直到所有的任务执行结束</span></span><br><span class="line">future.join();</span><br></pre></td></tr></table></figure><p>下面的程序演示了数字 1 ~ 10 并行进行三次方计算，并在完所有数字全部计算完成后输出结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Double&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        CompletableFuture.allOf(IntStream.range(<span class="number">1</span>, <span class="number">10</span>).boxed()</span><br><span class="line">                .map(e -&gt; CompletableFuture.runAsync(() -&gt; result.add(pow3(e))))</span><br><span class="line">                .toArray(CompletableFuture[]::<span class="keyword">new</span>)</span><br><span class="line">        ).join();</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">pow3</span><span class="params">(<span class="keyword">double</span> input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.pow(input, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1.0</span>, <span class="number">8.0</span>, <span class="number">27.0</span>, <span class="number">64.0</span>, <span class="number">125.0</span>, <span class="number">729.0</span>, <span class="number">216.0</span>, <span class="number">343.0</span>, <span class="number">512.0</span>]</span><br></pre></td></tr></table></figure><h4 id="522-anyof"><a class="markdownIt-Anchor" href="#522-anyof"></a> 5.2.2 anyOf</h4><p>anyOf 也很容易理解，就是只要有任意一个 CompletableFuture 任务执行完成就会返回。</p><p>下面的程序演示了数字 1 ~ 10 并行进行三次方计算，只要有任意一个数字计算完成后就会输出结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object anyResult = CompletableFuture.anyOf(IntStream.range(<span class="number">1</span>, <span class="number">10</span>).boxed()</span><br><span class="line">                .map(e -&gt; CompletableFuture.supplyAsync(() -&gt; pow3(e)))</span><br><span class="line">                .toArray(CompletableFuture[]::<span class="keyword">new</span>)</span><br><span class="line">        ).join();</span><br><span class="line"></span><br><span class="line">        System.out.println(anyResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">pow3</span><span class="params">(<span class="keyword">double</span> input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.pow(input, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于线程执行先后的不同，每次运行输出结果都不一样，因此我就不贴出运行接过来。</p><blockquote><p>之所以它的返回值使用的是 Object，因为每个任务可能返回的类型不同，它自身无法判断类型。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-前言&quot;&gt;&lt;/a&gt; 一、前言&lt;/h2&gt;
&lt;p&gt;本文向大家安利一下 JDK 8 中的并发工具类 &lt;code&gt;CompletableFuture&lt;/code&gt;，利用它可以方便的进行并</summary>
      
    
    
    
    <category term="Java" scheme="https://jitwxs.cn/categories/Java/"/>
    
    <category term="并发编程" scheme="https://jitwxs.cn/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Slf4j 包冲突问题原因与解决</title>
    <link href="https://jitwxs.cn/e2390047.html"/>
    <id>https://jitwxs.cn/e2390047.html</id>
    <published>2020-12-06T15:57:23.000Z</published>
    <updated>2020-12-26T13:52:06.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言"></a> 一、前言</h2><p>在进行 Java 开发时，通常我们会选择 Slf4j 作为日志门面，但日志实现却不尽相同。如果系统运行中同时存在多个日志实现，就会出现类似下图的 Warning。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201206230550.png" alt="" /></p><h2 id="二-问题原因"><a class="markdownIt-Anchor" href="#二-问题原因"></a> 二、问题原因</h2><p>我们知道 SpringBoot 默认使用的日志实现是 Logback，因此我们尝试在项目中引入 Log4j 的依赖时，就复现了上图的报错。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上图报错告知我们存在多个 SLF4J bingdings，分别位于 logback 和 log4j 包中，有两个 <code>StaticLoggerBinder</code>。</p><p>我们知道使用 Slf4j ，需要 <code>LoggerFactory.getLogger()</code>  方法获取实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Logger logs = LoggerFactory.getLogger(xxx.class);</span><br></pre></td></tr></table></figure><p>我们就可以通过这个作为入口，去看看源码的实现。如下图所示，我标注了需要关注的核心代码。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201206232119.png" alt="" /></p><p>（1）调用 <code>getILoggerFactory()</code> 方法得到 LoggerFactory。</p><p>（2）对于首次调用，<code>INITIALIZATION_STATE</code> 应该是 UNINITIALIZED，所以进入初始化的逻辑，调用方法 <code>performInitialization()</code>。</p><p>（3）调用 <code>bind()</code> 方法。</p><p>（4）如果不是 <code>isAndroid()</code>，调用 <code>findPossibleStaticLoggerBinderPathSet()</code> 方法，故名思意，查找可能的 staticLoggerBinder，注意这里返回的类型是 SET，即可能是多个。</p><p>（5）在<code>findPossibleStaticLoggerBinderPathSet()</code> 这个方法内，首先通过 classLoader 加载了 <code>org/slf4j/impl/StaticLoggerBinder.class</code> 这个类的 path，它可能存在多个，因此使用了 while 获取了所有的 path，并最终返回。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201206232900.png" alt="" /></p><p>（6）<code>reportActualBinding()</code> 方法会校验 SET 的 size，如果大于 1，就会打印出一开始我们看见的 Warning 了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201206233518.png" alt="" /></p><h2 id="三-问题解决"><a class="markdownIt-Anchor" href="#三-问题解决"></a> 三、问题解决</h2><p>解决思路就是将你不想要的日志实现从依赖包中排除掉即可，通过 IDEA 提供的 <code>Diagrams</code> 能够非常方便的查看项目中的依赖关系。</p><p>打开项目的 POM 文件，右键选择 <code>Diagrams -&gt; Show Dependencies</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201206233647.png" alt="" /></p><p>假设我们想要排除 logback 依赖，使用 log4j。<code>Ctrl + F</code> 搜索 <code>logback</code>，可以找到引用该依赖的树形结构。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201206234031.png" alt="" /></p><p>点击窗口左上角的下图中的这个图标，可以只看当前选中的这个依赖的关系。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201206234108.png" alt="" /></p><p>选中后效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202012/20201206234057.png" alt="" /></p><p>如上图所示，logback 由 <code>spring-boot-starter-logging</code> 引入，最顶层是由 <code>spring-boot-starter-web</code> 和 <code>spring-boot-starter-test</code> 引入。</p><p>我们尝试在 <code>spring-boot-starter-web</code> 中排除该依赖，应该就可以了。如果排出后重新搜索仍然存在 logback 依赖，则重复执行排除的操作。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="四-总结"><a class="markdownIt-Anchor" href="#四-总结"></a> 四、总结</h2><p>日志框架冲突特别对于新手来说处理起来比较头疼，因为涉及到了日志接口和日志实现。</p><p>我们推崇的应该是面向接口编程，因此我们大到开源项目，小到公司的公共 jar 包，应当合理利用 Maven 的传递机制。具体的日志实现不应该传递出去，避免影响到调用的下游方。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-前言&quot;&gt;&lt;/a&gt; 一、前言&lt;/h2&gt;
&lt;p&gt;在进行 Java 开发时，通常我们会选择 Slf4j 作为日志门面，但日志实现却不尽相同。如果系统运行中同时存在多个日志实现，就会出</summary>
      
    
    
    
    <category term="Java" scheme="https://jitwxs.cn/categories/Java/"/>
    
    <category term="日志框架" scheme="https://jitwxs.cn/categories/Java/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot Metrics 监控系统（4）——使用指标</title>
    <link href="https://jitwxs.cn/dad9ec18.html"/>
    <id>https://jitwxs.cn/dad9ec18.html</id>
    <published>2020-11-15T13:34:35.000Z</published>
    <updated>2021-02-21T13:28:54.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言"></a> 一、前言</h2><p>在正式讲解之前，我们先把上一节缺省的地方补齐。</p><h3 id="11-枚举类实现"><a class="markdownIt-Anchor" href="#11-枚举类实现"></a> 1.1 枚举类实现</h3><p>IMetricsEnum 和 IMetricsTagEnum 均为接口定义，下面我直接给出它们的实现类。具体的每个指标含义下面会详细讲解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">MetricsEnum</span> <span class="keyword">implements</span> <span class="title">IMetricsEnum</span> </span>&#123;</span><br><span class="line">    READ_COUNT(<span class="string">&quot;read_count&quot;</span>, Type.COUNTER, <span class="string">&quot;阅读量统计&quot;</span>),</span><br><span class="line">    VISITOR_SIZE(<span class="string">&quot;visitor_size&quot;</span>, Type.GAUGE, <span class="string">&quot;访问量统计&quot;</span>),</span><br><span class="line">    REQUEST_TIME(<span class="string">&quot;request_time&quot;</span>,Type.TIMER, <span class="string">&quot;请求耗时&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">MetricsTagEnum</span> <span class="keyword">implements</span> <span class="title">IMetricsTagEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    READ_COUNT_1(MetricsEnum.READ_COUNT, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;video_name&quot;</span>, <span class="string">&quot;法外狂徒张三&quot;</span>&#125;),</span><br><span class="line">    READ_COUNT_2(MetricsEnum.READ_COUNT, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;video_name&quot;</span>, <span class="string">&quot;不讲武德年轻人&quot;</span>&#125;),</span><br><span class="line"></span><br><span class="line">    SYSTEM_VISITOR_SIZE(MetricsEnum.VISITOR_SIZE, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;type&quot;</span>, <span class="string">&quot;system&quot;</span>&#125;),</span><br><span class="line"></span><br><span class="line">    USERINFO_REQUEST_TIME(MetricsEnum.REQUEST_TIME, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;url&quot;</span>, <span class="string">&quot;/userInfo&quot;</span>&#125;),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IMetricsEnum metricsEnum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] tags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-一键注册指标"><a class="markdownIt-Anchor" href="#12-一键注册指标"></a> 1.2 一键注册指标</h3><p>对于交给 IMetricsTagEnum 类管理的指标，在 <code>BaseMetricsUtil</code> 类中提供了一键注册的方法，我们仅需要在程序启动成功后调用下即可。为了方便起见，我就直接写在启动类中了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetricsApplication</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MetricsApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 注册指标</span></span><br><span class="line">        MetricsUtil.init(MetricsTagEnum.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别需要注意的是，启动类增加了 <code>@EnableScheduling</code> 注解，这是因为本节模拟的指标数据都是用定时任务产生的。</p><h2 id="二-metrics-埋点"><a class="markdownIt-Anchor" href="#二-metrics-埋点"></a> 二、Metrics 埋点</h2><h3 id="21-counter"><a class="markdownIt-Anchor" href="#21-counter"></a> 2.1 Counter</h3><p>先来介绍下最简单的 <code>Counter</code> 类型，它是不断递增的一种数据结构，你可以将其理解为<strong>计数器</strong>。</p><p>假设我们想要统计两部视频的阅读量：</p><p>（1）在 MetricsEnum 中定义阅读量的指标：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">READ_COUNT(<span class="string">&quot;read_count&quot;</span>, Type.COUNTER, <span class="string">&quot;阅读量统计&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>name</code> Metrics 指标的名字</li><li><code>type</code> 自定义的 Metrics 的类型，用于初始化的时候去 Prometheus 注册哪种 Metrics</li><li><code>description</code> Metrics 指标的描述</li></ul><p>（2）在 MetricsTagEnum 中定义具体的指标实现，如下所以，我们定义了两个 video_name 不同的阅读量指标：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">READ_COUNT_1(MetricsEnum.READ_COUNT, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;video_name&quot;</span>, <span class="string">&quot;法外狂徒张三&quot;</span>&#125;),</span><br><span class="line">READ_COUNT_2(MetricsEnum.READ_COUNT, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;video_name&quot;</span>, <span class="string">&quot;不讲武德年轻人&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>metricsEnum</code> 指定所属的 MetricsEnum</li><li><code>tags</code> 该 Metrics 对应的 label（在不同系统中叫法不一样，在 java 中就是叫 tag），必须成对出现，其实就是一组组键值对。</li></ul><p>下面来写一个定时任务，去模拟阅读量的递增：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockReadCountScheduler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(initialDelay = 100, fixedDelay = 1000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mockReadCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> value1 = <span class="keyword">new</span> Random().nextDouble();</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">            MetricsUtil.recordCounter(MetricsTagEnum.READ_COUNT_1, value1);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">double</span> value2 = <span class="keyword">new</span> Random().nextDouble();</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">            MetricsUtil.recordCounter(MetricsTagEnum.READ_COUNT_2, value2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试启动程序，访问 <code>http://127.0.0.1:7002/prometheus</code> ，你应该能够看到这两个 metrics 已经出现在其中了，并且随着每次刷新，其数值都会自增。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201115220055.png" alt="" /></p><h3 id="22-gauge"><a class="markdownIt-Anchor" href="#22-gauge"></a> 2.2 Gauge</h3><p>让我们关闭程序，继续学习 Gauge 吧。Gauge 官方名称叫做测量仪，Prometheus 每隔一段时间（称为采集间隔）就会访问一次 Metrics 端口，访问的这一刻这个值是多少就是多少。</p><p>因此使用 Gauge 的指标的数值可增可减，没有先后关系。方便用于统计系统的实时信息，例如访客数、每分钟阅读量等等。</p><p>假设我们想要统计系统此时的访客数：</p><p>（1）在 MetricsEnum 中定义访问量的指标：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VISITOR_SIZE(<span class="string">&quot;visitor_size&quot;</span>, Type.GAUGE, <span class="string">&quot;访问量统计&quot;</span>)</span><br></pre></td></tr></table></figure><p>（2）在 MetricsTagEnum 中定义具体的指标实现，如系统访问量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYSTEM_VISITOR_SIZE(MetricsEnum.VISITOR_SIZE, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;type&quot;</span>, <span class="string">&quot;system&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>咱们来写一个定时任务，去模拟实时的访客数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockVisitorSizeScheduler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Scheduled(initialDelay = 100, fixedDelay = 1500)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mockVisitorSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> visitorSize = <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">        MetricsUtil.recordTimerOrGauge(MetricsTagEnum.SYSTEM_VISITOR_SIZE, visitorSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序后，一样能够找到这个指标。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201115220132.png" alt="" /></p><h3 id="23-timer"><a class="markdownIt-Anchor" href="#23-timer"></a> 2.3 Timer</h3><p>Timer 类型的指标，适合用于统计一些耗时，也能够方便的进行百分位统计。</p><p>这里初学者包括我刚刚用的时候，就会习惯用 Gauge 去做耗时统计而不是用 Timer 类型。Gauge 类型的特点是测量仪，Promethues 默认的采集时间是 60s，那么使用 Gauge 统计耗时其实就是统计每隔 15s 你的耗时。这其实就是一个非常粗粒度的采集，60s 间隔内的耗时 Prometheus 都没采集到。</p><p>而 Timer 不一样，它有一个显著特点是<strong>客户端计算</strong>。Prometheus 你不是 60s 采集我一次嘛，没关系，我在客户端内记录下你调用 Timer 的次数（count）、总和（sum）、最大值（max）。这样 Prometheus 采集到的就不同于 Gauge 的粗粒度的、单独的一个数据，而是一个最小粒度的数据。</p><p>解释完 Timer 和 Gauge 的区别后，开始我们的例子吧。</p><p>假设我们想要统计系统某接口的响应时间：</p><p>（1）在 MetricsEnum 中定义请求耗时的指标：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REQUEST_TIME(<span class="string">&quot;request_time&quot;</span>,Type.TIMER, <span class="string">&quot;请求耗时&quot;</span>)</span><br></pre></td></tr></table></figure><p>（2）在 MetricsTagEnum 中定义具体的指标实现，如 userInfo 这个接口的请求耗时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USERINFO_REQUEST_TIME(MetricsEnum.REQUEST_TIME, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;url&quot;</span>, <span class="string">&quot;/userInfo&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>咱们来写一个定时任务，去模拟这个接口的响应时间变化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockRequestTimeScheduler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Scheduled(initialDelay = 100, fixedDelay = 1500)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mockVisitorSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MetricsUtil.recordTimerOrGauge(MetricsTagEnum.USERINFO_REQUEST_TIME, <span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201115233933.png" alt="" /></p><h2 id="四-连接-prometheus"><a class="markdownIt-Anchor" href="#四-连接-prometheus"></a> 四、连接 Prometheus</h2><p>我们需要编辑 prometheus 配置文件，我试了下 Docker 的 Promethues 配置变更不支持热部署，所以需要先通过 Docker Dashboard 将 Prometheus 容器关闭。</p><p>然后编辑 <code>prometheus.yml</code> 文件，增加一个节点：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201115225008.png" alt="" /></p><p>这里多了一个 <code>metrics_path</code>，是因为 prometheus 默认采集的 <code>/metrics</code> 路径，而我们是用的 <code>/prometheus</code> 路径，所以要显式声明一下。或者修改程序的配置文件，加入如下两行也是一样的效果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201115223930.png" alt="" /></p><p>【注：这里有个坑，因为我的 Prometheus 和 Grafana 都是用容器启动的，所以它们之间用 localhost 是可以连接的。但是我的 SpringBoot 应用跑在容器外，Prometheus 连接 SpringBoot 应用就必须用我物理机的 IP，不能用 localhost】</p><p>将 Prometheus 重新启动后，进入 <code>Status -&gt; Targets</code> 等我们的服务变成 UP 就连接完毕了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201115225332.png" alt="" /></p><h2 id="五-grafana"><a class="markdownIt-Anchor" href="#五-grafana"></a> 五、Grafana</h2><p>下面我们尝试在 Grafana 中将我们的指标渲染出来。</p><h3 id="51-counter"><a class="markdownIt-Anchor" href="#51-counter"></a> 5.1 Counter</h3><p>这张图表将展示视频阅读量在 5 分钟内的增速：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201115230117.png" alt="" /></p><h3 id="52-gauge"><a class="markdownIt-Anchor" href="#52-gauge"></a> 5.2 Gauge</h3><p>这张图表将展示系统当前的访客数信息：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201115230737.png" alt="" /></p><h3 id="53-timer"><a class="markdownIt-Anchor" href="#53-timer"></a> 5.3 Timer</h3><p>这张图表将展示接口的平均耗时信息：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201115231305.png" alt="" /></p><p>这张图表将展示接口的百分位耗时信息：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201115234750.png" alt="" /></p><h2 id="六-结尾"><a class="markdownIt-Anchor" href="#六-结尾"></a> 六、结尾</h2><p>至此完成了在程序中进行 Metrics 埋点，并结合 Prometheus 和 Grafana，在大盘中可视化展示出来。Grafana 的可配置项很多，还需要大家自己去尝试和摸索。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-前言&quot;&gt;&lt;/a&gt; 一、前言&lt;/h2&gt;
&lt;p&gt;在正式讲解之前，我们先把上一节缺省的地方补齐。&lt;/p&gt;
&lt;h3 id=&quot;11-枚举类实现&quot;&gt;&lt;a class=&quot;markdownIt</summary>
      
    
    
    
    <category term="云原生" scheme="https://jitwxs.cn/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="SpringBoot" scheme="https://jitwxs.cn/tags/SpringBoot/"/>
    
    <category term="Prometheus" scheme="https://jitwxs.cn/tags/Prometheus/"/>
    
    <category term="Grafana" scheme="https://jitwxs.cn/tags/Grafana/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Metrics 监控系统（3）——搭建框架</title>
    <link href="https://jitwxs.cn/527f9dce.html"/>
    <id>https://jitwxs.cn/527f9dce.html</id>
    <published>2020-11-15T13:06:13.000Z</published>
    <updated>2021-02-21T13:28:43.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言"></a> 一、前言</h2><p>本章节开始将为大家展示如何在 SpringBoot 应用中去使用 Metrics 监控。本系列使用的 SpringBoot 版本为笔者当前的最新 RELAESE 版本 <code>2.4.0</code>，整个 SpringBoot 2 关于这边都是大同小异，所以大家不用担心版本问题。</p><h2 id="二-依赖包"><a class="markdownIt-Anchor" href="#二-依赖包"></a> 二、依赖包</h2><p>除了常规开发 SpringBoot Web 所需要的两个包外：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们还需要导入 SpringBoot 的监控端点 actuator 包和 Prometheus 包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-registry-prometheus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外为了便于开发，我还使用了 Lombok：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="三-metrics-enums"><a class="markdownIt-Anchor" href="#三-metrics-enums"></a> 三、Metrics Enums</h2><p>对于刚刚入门使用的同学，经常会出现 Metrics 指标的管理混乱的情况。在代码里这处注册一个指标，那处注册一个，很混乱。因此有必要提供一个类，专门管理所有的 Metrics 指标并统一注册。这里我使用枚举类实现，当然你也可以根据自己需要使用其他方式实现。</p><h3 id="31-imetricsenum"><a class="markdownIt-Anchor" href="#31-imetricsenum"></a> 3.1 IMetricsEnum</h3><p>Metrics 监控指标枚举，定义了指标的类型和名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMetricsEnum</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;GAUGE, COUNTER, TIMER&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Type <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getDesc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> IMetricsTagEnum <span class="title">createVirtualMetricsTagEnum</span><span class="params">(String[] tags)</span> </span>&#123;</span><br><span class="line">        IMetricsEnum iMetricsEnum = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IMetricsTagEnum() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> IMetricsEnum <span class="title">getMetricsEnum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> iMetricsEnum;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String[] getTags() &#123;</span><br><span class="line">                <span class="keyword">return</span> tags;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="32-imetricstagenum"><a class="markdownIt-Anchor" href="#32-imetricstagenum"></a> 3.2 IMetricsTagEnum</h3><p>负责维护所有的 Metrics 指标，是实际生效的 Metrics 指标。相较于 IMetricsEnum，需要额外指定 tag 属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMetricsTagEnum</span> </span>&#123;</span><br><span class="line">    String FUNCTION = <span class="string">&quot;function&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">IMetricsEnum <span class="title">getMetricsEnum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    String[] getTags();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-metrics-support"><a class="markdownIt-Anchor" href="#四-metrics-support"></a> 四、Metrics Support</h2><p>首先编写一些使用 Prometheus 的 Metrics 的工具类，一共有以下几个类：</p><ul><li><code>MetricsRegisterConfig</code> 交于 Spring 容器管理，负责获取到 Prometheus 的全局实例对象</li><li><code>BaseMetricsUtil</code> 基础的 Metrics 工具类，抽取一些共用方法</li><li><code>MetricsUtil</code> Metrics 注册和各个类型指标值记录的工具类</li></ul><h3 id="41-metricsregisterconfig"><a class="markdownIt-Anchor" href="#41-metricsregisterconfig"></a> 4.1 MetricsRegisterConfig</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetricsRegisterConfig</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.application.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String applicationName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bean <span class="keyword">instanceof</span> MeterRegistry) &#123;</span><br><span class="line">            MeterRegistry registry = (MeterRegistry) bean;</span><br><span class="line">            registry.config().commonTags(<span class="string">&quot;application&quot;</span>, applicationName);</span><br><span class="line"></span><br><span class="line">            BaseMetricsUtil.meterRegistry = registry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="42-basemetricsutil"><a class="markdownIt-Anchor" href="#42-basemetricsutil"></a> 4.2 BaseMetricsUtil</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseMetricsUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MeterRegistry meterRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> String CLASS_NAME = <span class="keyword">new</span> Object() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String clazzName = <span class="keyword">this</span>.getClass().getName();</span><br><span class="line">            <span class="keyword">return</span> clazzName.substring(<span class="number">0</span>, clazzName.lastIndexOf(<span class="string">&quot;$&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.getClassName();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">basicCheck</span><span class="params">(<span class="keyword">final</span> IMetricsTagEnum metricsTagEnum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (meterRegistry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;metrics registry is null,class=&#123;&#125;&quot;</span>, CLASS_NAME);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String[] tags = metricsTagEnum.getTags();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tags != <span class="keyword">null</span> &amp;&amp; tags.length % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;metrics count error,class=&#123;&#125;,tags=&#123;&#125;&quot;</span>, CLASS_NAME, tags);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="43-metricsutil"><a class="markdownIt-Anchor" href="#43-metricsutil"></a> 4.3 MetricsUtil</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetricsUtil</span> <span class="keyword">extends</span> <span class="title">BaseMetricsUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;IMetricsTagEnum, MetricsWrapper&gt; METRICS_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ThreadPoolUtil.newScheduledExecutor(<span class="number">1</span>, <span class="string">&quot;metrics-manager-thread-pool&quot;</span>).scheduleWithFixedDelay(() -&gt; METRICS_MAP.values().stream()</span><br><span class="line">                .filter(e -&gt; e.getType() != IMetricsEnum.Type.COUNTER).filter(e -&gt; TimeUtils.diffMs(e.getLastTime()) &gt; <span class="number">10_000</span>)</span><br><span class="line">                .forEach(e -&gt; e.recordTimerOrGauge(<span class="number">0L</span>)), <span class="number">15</span>, <span class="number">15</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * For IMetricsTagEnum</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends IMetricsTagEnum&gt; <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = clazz.getDeclaredMethod(<span class="string">&quot;values&quot;</span>);</span><br><span class="line">            simpleRegister((T[]) method.invoke(<span class="keyword">null</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;metrics gauge error,class=&#123;&#125;&quot;</span>, clazz.getSimpleName(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * For RingBuffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerGauge</span><span class="params">(<span class="keyword">final</span> IMetricsTagEnum metricsTagEnum,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">final</span> Supplier&lt;Number&gt; supplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!basicCheck(metricsTagEnum)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Gauge.builder(metricsTagEnum.getMetricsEnum().getName(), supplier)</span><br><span class="line">                .tags(metricsTagEnum.getTags())</span><br><span class="line">                .description(metricsTagEnum.getMetricsEnum().getDesc())</span><br><span class="line">                .register(meterRegistry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * For Common</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simpleRegister</span><span class="params">(IMetricsTagEnum... metricsTagEnums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (metricsTagEnums != <span class="keyword">null</span> &amp;&amp; metricsTagEnums.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (IMetricsTagEnum metricsTagEnum : metricsTagEnums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!basicCheck(metricsTagEnum)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> IMetricsEnum.Type type = metricsTagEnum.getMetricsEnum().getType();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (type == IMetricsEnum.Type.GAUGE) &#123;</span><br><span class="line">                    Gauge.builder(metricsTagEnum.getMetricsEnum().getName(), METRICS_MAP, m -&gt; (<span class="keyword">long</span>) m.get(metricsTagEnum).getMetrics())</span><br><span class="line">                            .tags(metricsTagEnum.getTags())</span><br><span class="line">                            .description(metricsTagEnum.getMetricsEnum().getDesc())</span><br><span class="line">                            .register(meterRegistry);</span><br><span class="line"></span><br><span class="line">                    METRICS_MAP.put(metricsTagEnum, MetricsWrapper.newInstance(type, <span class="number">0L</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == IMetricsEnum.Type.COUNTER) &#123;</span><br><span class="line">                    <span class="keyword">final</span> Counter cnt = Counter.builder(metricsTagEnum.getMetricsEnum().getName())</span><br><span class="line">                            .tags(metricsTagEnum.getTags())</span><br><span class="line">                            .description(metricsTagEnum.getMetricsEnum().getDesc())</span><br><span class="line">                            .register(meterRegistry);</span><br><span class="line"></span><br><span class="line">                    METRICS_MAP.put(metricsTagEnum, MetricsWrapper.newInstance(type, cnt));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == IMetricsEnum.Type.TIMER) &#123;</span><br><span class="line">                    <span class="keyword">final</span> Timer timer = Timer.builder(metricsTagEnum.getMetricsEnum().getName())</span><br><span class="line">                            .tags(metricsTagEnum.getTags())</span><br><span class="line">                            .description(metricsTagEnum.getMetricsEnum().getDesc())</span><br><span class="line">                            .publishPercentiles(<span class="number">0.5</span>, <span class="number">0.9</span>, <span class="number">0.95</span>, <span class="number">0.99</span>)</span><br><span class="line">                            .register(meterRegistry);</span><br><span class="line"></span><br><span class="line">                    METRICS_MAP.put(metricsTagEnum, MetricsWrapper.newInstance(type, timer));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * For Counter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recordCounter</span><span class="params">(IMetricsTagEnum metricsTagEnum)</span> </span>&#123;</span><br><span class="line">        recordCounter(metricsTagEnum, <span class="number">1.0D</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * For Counter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recordCounter</span><span class="params">(IMetricsTagEnum metricsTagEnum, <span class="keyword">double</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (METRICS_MAP.containsKey(metricsTagEnum)) &#123;</span><br><span class="line">            METRICS_MAP.get(metricsTagEnum).recordCounter(size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * For Timer、Gauge</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recordTimerOrGauge</span><span class="params">(<span class="keyword">final</span> IMetricsTagEnum metricsTagEnum, <span class="keyword">final</span> <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (METRICS_MAP.containsKey(metricsTagEnum)) &#123;</span><br><span class="line">            METRICS_MAP.get(metricsTagEnum).recordTimerOrGauge(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MetricsWrapper</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> IMetricsEnum.Type type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Object metrics;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> lastTime = TimeUtils.nowMs();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MetricsWrapper <span class="title">newInstance</span><span class="params">(IMetricsEnum.Type type, Object metrics)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MetricsWrapper(type, metrics, TimeUtils.nowMs());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recordCounter</span><span class="params">(<span class="keyword">final</span> <span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">            ((Counter) <span class="keyword">this</span>.metrics).increment(value);</span><br><span class="line">            <span class="keyword">this</span>.lastTime = TimeUtils.nowMs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordTimerOrGauge</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.type == IMetricsEnum.Type.TIMER) &#123;</span><br><span class="line">                ((Timer) <span class="keyword">this</span>.metrics).record(value, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.type == IMetricsEnum.Type.GAUGE) &#123;</span><br><span class="line">                <span class="keyword">this</span>.metrics = value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.lastTime = TimeUtils.nowMs();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五-applicaitonyaml"><a class="markdownIt-Anchor" href="#五-applicaitonyaml"></a> 五、applicaiton.yaml</h2><p>编辑程序的配置文件，主要是 <code>management</code> 相关的配置。</p><ul><li><code>management.server.port</code> 指定暴露的监控端点</li><li><code>management.endpoints.web.base-path</code> SpringBoot 程序监控默认的根路径是 <code>/actuator</code>，我嫌它麻烦，给改成 <code>/</code> 了</li><li><code>management.endpoints.web.exposure.include</code> SpringBoot 默认情况会将所有信息都暴露出去，这里我改成只暴露一部分，主要用的就是那个 <code>prometheus</code>【生产环境这些内容要么要加权限控制，要么尽量减少暴露部分，减少泄露信息的可能】</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">7002</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">base-path:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">health,</span> <span class="string">info,</span> <span class="string">prometheus</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">metrics-sample</span></span><br></pre></td></tr></table></figure><h2 id="六-结语"><a class="markdownIt-Anchor" href="#六-结语"></a> 六、结语</h2><p>至此完成 SpringBoot Metrics 监控系统框架的搭建，下一节将开始演示指标的使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-前言&quot;&gt;&lt;/a&gt; 一、前言&lt;/h2&gt;
&lt;p&gt;本章节开始将为大家展示如何在 SpringBoot 应用中去使用 Metrics 监控。本系列使用的 SpringBoot 版本为笔</summary>
      
    
    
    
    <category term="云原生" scheme="https://jitwxs.cn/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="SpringBoot" scheme="https://jitwxs.cn/tags/SpringBoot/"/>
    
    <category term="Prometheus" scheme="https://jitwxs.cn/tags/Prometheus/"/>
    
    <category term="Grafana" scheme="https://jitwxs.cn/tags/Grafana/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Metrics 监控系统（2）——快速起步</title>
    <link href="https://jitwxs.cn/1e8d61b4.html"/>
    <id>https://jitwxs.cn/1e8d61b4.html</id>
    <published>2020-11-14T08:45:49.000Z</published>
    <updated>2020-12-26T13:52:06.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-docker"><a class="markdownIt-Anchor" href="#一-docker"></a> 一、Docker</h2><p>首先需要安装 Docker，已经安装的朋友直接跳过该节即可。</p><p>Docker 最近新出了 Docker Desktop，可以对容器和镜像可视化管理，还是很不错的。访问<a href="https://www.docker.com/get-started">官网</a></p><p>下载即可，这里我使用 Windows 平台进行安装。【最好采用科学上网，否则速度会很感人】</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201114164928.png" alt="" /></p><p>如果安装完毕后打开报下图的错，需要在更新下 WSL2，<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">点此下载</a>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201114165548.png" alt="" /></p><p>启动成功后如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201114170114.png" alt="" /></p><h2 id="二-prometheus-grafana"><a class="markdownIt-Anchor" href="#二-prometheus-grafana"></a> 二、Prometheus + Grafana</h2><p>打开 PowerShell 或其他命令行工具，下载镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull prom/prometheus</span><br></pre></td></tr></table></figure><p>下载完毕后，提前准备好配置文件，新建配置文件 <code>prometheus.yml</code>，内容如下。将其保存到任一位置即可，并记录下它的绝对路径。我这里把它放置在了桌面，因此它的绝对路径是：<code>C:\Users\Jitwxs\Desktop\prometheus.yml</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span>     <span class="string">60s</span></span><br><span class="line">  <span class="attr">evaluation_interval:</span> <span class="string">60s</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:9090&#x27;</span>]</span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">instance:</span> <span class="string">prometheus</span></span><br></pre></td></tr></table></figure><p>执行命令启动容器【注意命令中的绝对路径，需要替换成你自己实际的路径】：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run  -d -p 9090:9090 -v C:\Users\Jitwxs\Desktop\prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus</span><br></pre></td></tr></table></figure><p>执行完毕后，打开 Docker 客户端，可以看到 Prometheus 已经启动成功，在 <code>Mounts</code> 中可以看到配置文件也被挂载到容器内。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201114184154.png" alt="" /></p><p>打开浏览器，输入 <code>http://127.0.0.1:9090</code> 即可登录 Prometheus，选择 <code>Status -&gt; Configuration</code> 也能看到我们的配置文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201114184330.png" alt="" /></p><p>至此 Prometheus 的起步就完成了，下面来启动 Grafana 把。</p><h2 id="三-grafana"><a class="markdownIt-Anchor" href="#三-grafana"></a> 三、Grafana</h2><p>下载镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull grafana/grafana</span><br></pre></td></tr></table></figure><p>启动容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3000:3000 --name=grafana grafana/grafana</span><br></pre></td></tr></table></figure><p>执行完毕后，打开 Docker 客户端，可以看到 Grafana 已经启动成功。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201114190856.png" alt="" /></p><p>打开浏览器，输入 <code>http://127.0.0.1:3000</code>，即可登录 Grafana 首页，使用默认用户名密码 admin 登录即可。</p><p>首先配置下 Grafana 的数据源，点击右侧⚙图标，选择 <code>Data Sources</code> 选项卡，然后选择 右侧的 Prometheus。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201114191115.png" alt="" /></p><p>并做以下配置：</p><ul><li>URL: <code>http://127.0.0.1:9090</code></li><li>Access: <code>Browser</code></li></ul><p>然后点击下方 <code>Save &amp; Test</code> 按钮，弹出 <code>Data source is working</code> 的绿色提示即可。</p><p>【注意：如果弹出的是红色的<code>HTTP Error Bad Gateway</code>，尝试将 Access 改为 <code>Server</code> 试试看】</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201114191345.png" alt="" /></p><p>至此完成 Grafana 的起步。</p><h2 id="四-入门实例"><a class="markdownIt-Anchor" href="#四-入门实例"></a> 四、入门实例</h2><p>下面展示一个简单的心跳监测的功能，Prometheus 服务自身也会对外暴露一些 Metrics，下面来实现如何在 Grafana 上侦听 Prometheus 服务是否存活。</p><p>我们在 Prometheus 的首页上，搜索一个名为 <code>up</code> 的 metrics，搜索结果中有一条，它有两个 label，通过 <code>instance</code> 这个 label 得知这条记录就是 prometheus 提供的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201114233624.png" alt="" /></p><p>切换到 Grafana 上，点击左侧的加号，点击 Dashboard，会创建一个 Dashboard。然后我们选择 <code>Add new panel</code>，新建一个面板。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201114233824.png" alt="" /></p><p>在下面的 PromQL 表达式上输入刚刚的 metrics，然后将图表从默认的 <code>Graph</code> 改为 <code>Stat</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201114234006.png" alt="" /></p><p>对于 <code>up</code> 这个 metrics，可能的取值有 1 和不存在。我们可以通过 Value Mapping 功能，将取值和实际的展示的内容作对应。同时对于不同的取值，也可以指定配色。</p><p>如下图所示，我将 1 映射为 UP，将 null 映射为 DOWN。同时，将 1 颜色指定为绿色，0 指定为红色。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201114234417.png" alt="" /></p><p>另外图表下方的 Graph 展示了这个数值在不同时间的变化情况，假设我们只想关心当前的，不想关心这个服务什么时候 UP 什么时候 DOWN，可以将其隐藏掉。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201114234700.png" alt="" /></p><p>至此这个 Panel 就制作好了，返回到 Dashboard 后形如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201114234720.png" alt="" /></p><p>让我们尝试关闭掉 prometheus 服务</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201114234820.png" alt="" /></p><p>点击 Grafana Dashboard 右上角的刷新后，发现变成了 DOWN。将 Prometheus 服务恢复后，又恢复正常。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201114234911.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-docker&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-docker&quot;&gt;&lt;/a&gt; 一、Docker&lt;/h2&gt;
&lt;p&gt;首先需要安装 Docker，已经安装的朋友直接跳过该节即可。&lt;/p&gt;
&lt;p&gt;Docker 最近新出了 Doc</summary>
      
    
    
    
    <category term="云原生" scheme="https://jitwxs.cn/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="SpringBoot" scheme="https://jitwxs.cn/tags/SpringBoot/"/>
    
    <category term="Prometheus" scheme="https://jitwxs.cn/tags/Prometheus/"/>
    
    <category term="Grafana" scheme="https://jitwxs.cn/tags/Grafana/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Metrics 监控系统（1）——技术介绍</title>
    <link href="https://jitwxs.cn/b8c50183.html"/>
    <id>https://jitwxs.cn/b8c50183.html</id>
    <published>2020-11-14T08:42:32.000Z</published>
    <updated>2020-12-26T13:52:06.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言"></a> 一、前言</h2><p>本系列将为大家介绍如何对我们的 SpringBoot 应用程序进行监控和告警，使用的技术为 Prometheus + Grafana。二者均采用 Docker 进行安装部署，实际工作中自己在生产环境搭建的可能性不大，因此我们关注的重点放在如何使用就好了。</p><h2 id="二-prometheus"><a class="markdownIt-Anchor" href="#二-prometheus"></a> 二、Prometheus</h2><p><a href="https://prometheus.io/">Prometheus</a> 是 Soundcloud 开发的一款开源的监控工具，其本质是一个时间序列数据库（TSDB），采用 Go 语言开发。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201114153234.png" alt="" /></p><p>它具有以下特点：</p><ul><li><strong>多维度</strong>：我们可以给指标数据添加多组标 Label，在展示时候可以作为筛选条件灵活选择。</li><li><strong>拉模式</strong>：Prometheus 采用 Pull 模式，我们的指标数据生成后，Prometheus 会主动来消费，我们不需要做额外操作。</li><li><strong>白盒&amp;黑盒监控</strong>均支持：无论什么维度的指标数据，都可以采集到，对 DevOps 友好。</li><li><strong>Metrics &amp; Alert</strong>：Prometheus 采集的是 Metrics 指标，而不是 logging 和 tracing。</li><li><strong>社区生态丰富</strong>：支持各种语言的客户端，并且有各种各样的 exporters，来实现黑盒监控。例如 Redis，我们可以通过 Redis Exporters，来实现对 Redis 性能指标的监控。</li></ul><h3 id="21-架构设计"><a class="markdownIt-Anchor" href="#21-架构设计"></a> 2.1 架构设计</h3><p>下图来源于 <a href="https://prometheus.io/docs/introduction/overview/">Promethues 官网</a>，较为清楚的简述了 Prometheus 的架构。</p><p>在架构图的左侧，展示了 Prometheus 如何从指标提供方去拉取 Metrics。</p><p>（1）在架构图的左下角，我们一开始说到，Prometheus 采用拉的方式获取 Metrics。有些服务（例如 Spring 应用程序），可以通过在程序内部进行埋点，然后通过端点将指标暴露出去；有些服务不能够埋点，是一个黑盒（例如 Redis），Prometheus可以通过第三方的 Exporters，这些 Exporters 可以将这些服务内部的 Metrics 抓取出来并暴露给 Prometheus拉取。</p><p>（3）在架构图的左上角，对于有些系统，不能通过拉的方式去获取 Metrics，例如一些周期性运行的 Job。对于这些系统（Short-lived jobs），Prometheus 提供了 Push 网关，我们需要在这些任务内部将 metrics 数据主动 Push 到 Pushgateway。Prometheus再主动去 Pushgateway 拉取 Metrics。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202011/20201114163126.png" alt="architecture" /></p><p>（4）在架构图的上方，介绍了 Prometheus如何去发现 Metrics 指标提供方暴露端点。对于 Push 模式的服务，Prometheus只需要去 Pushgateway 拉取即可；对于 Pull 模式的服务，支持静态配置（例如指定服务 IP/Port 等）和服务发现（例如 K8S 等）两种模式。</p><p>（5）在架构图的中央，介绍了 Prometheus 的核心组成模块。<code>Retrieval</code> 可以认为是一个 Job，它负责去发现暴露的端点，并去拉取数据。将数据存储在 TSDB 中，并持久化到本地。同时提供一个 HTTP Server，来查询 TSDB 中的数据。</p><p>（6）在架构图的右下方，Prometheus定义了一套 TSDB 的查询语法，称为 <code>PromQL</code>，全称为 Prometheus Query Language。通过 Prometheus 自己的 Web UI，或者是 Grafana，或者 Prometheus 提供的 API，就能够对 TSDB 数据进行查询和展示。</p><p>（7）在架构图的右上方，介绍了 Promethus 的告警模块。我们可以配置自定义的 Metrics 告警条件，当达到触发的阈值时，就会将告警信息 Push 到告警模块。告警模块本身并不产生告警信息，它接受到告警信息后，对信息进行<strong>分组、去重、路由</strong>（Emial、微信等）。</p><h3 id="22-metrics-种类"><a class="markdownIt-Anchor" href="#22-metrics-种类"></a> 2.2 Metrics 种类</h3><p>Promethues 支持以下四种 Metrics 种类：</p><p>（1）Counter 计数器：特点是自增的，适合用于统计接口请求数、下单数等。</p><p>（2）Gauge 测量仪：对当前值的一次快照，这个值可增可减，适合用于统计在线用户量等。</p><p>（3）Summary 汇总：在客户端计算，根据样本统计出百分位。例如统计链路耗时，TP99 是多少，TP95 是多少等。</p><p>（4）Histogram 直方图：通过分桶（bucket）的方式来统计样本的分布。比如统计接口的耗时，多少的请求落在 10ms - 20ms，多少的请求落在 20ms - 30ms 等。</p><h3 id="23-metrics-示例"><a class="markdownIt-Anchor" href="#23-metrics-示例"></a> 2.3 Metrics 示例</h3><p>一个 Metrics 指标形如下面所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># HELP http_requests_total Total number of Http requests made.</span><br><span class="line"># TYPE http_requests_total counter</span><br><span class="line">http_requests_total&#123;code&#x3D;200,path&#x3D;&quot;&#x2F;status&quot;&#125; 8</span><br></pre></td></tr></table></figure><ul><li>指标名为：<code>http_requests_total</code></li><li>指标类型为：<code>counter</code></li><li>该指标打了两个 Label（Tag），分别是 code 和 path，对应的 Value 是 200 和 /status</li><li>指标数值为：8</li></ul><h2 id="三-grafana"><a class="markdownIt-Anchor" href="#三-grafana"></a> 三、Grafana</h2><p>Grafana 是一款跨平台的开源的度量分析和可视化工具，可以通过将采集的数据查询然后可视化的展示，并及时通知。支持 InfuxDB、Prometheus 等主流 TSDB 作为数据源，本系列将使用它作为 Promethues 的数据消费方。</p><p>下面列出它的一些特点，有兴趣的朋友可以看看。</p><p>（1）展示方式：快速灵活的客户端图表，面板插件有许多不同方式的可视化指标和日志，官方库中具有丰富的仪表盘插件，比如热图、折线图、图表等多种展示方式；</p><p>（2）数据源：Graphite，InfluxDB，OpenTSDB，Prometheus，Elasticsearch，CloudWatch和KairosDB等；</p><p>（3）通知提醒：以可视方式定义最重要指标的警报规则，Grafana将不断计算并发送通知，在数据达到阈值时通过Slack、PagerDuty等获得通知；</p><p>（4）混合展示：在同一图表中混合使用不同的数据源，可以基于每个查询指定数据源，甚至自定义数据源；</p><p>（5）注释：使用来自不同数据源的丰富事件注释图表，将鼠标悬停在事件上会显示完整的事件元数据和标记；</p><p>（6）过滤器：Ad-hoc过滤器允许动态创建新的键/值过滤器，这些过滤器会自动应用于使用该数据源的所有查询。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-前言&quot;&gt;&lt;/a&gt; 一、前言&lt;/h2&gt;
&lt;p&gt;本系列将为大家介绍如何对我们的 SpringBoot 应用程序进行监控和告警，使用的技术为 Prometheus + Grafana</summary>
      
    
    
    
    <category term="云原生" scheme="https://jitwxs.cn/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="SpringBoot" scheme="https://jitwxs.cn/tags/SpringBoot/"/>
    
    <category term="Prometheus" scheme="https://jitwxs.cn/tags/Prometheus/"/>
    
    <category term="Grafana" scheme="https://jitwxs.cn/tags/Grafana/"/>
    
  </entry>
  
  <entry>
    <title>使用 Fiddler 进行模拟器抓包</title>
    <link href="https://jitwxs.cn/f6ed356a.html"/>
    <id>https://jitwxs.cn/f6ed356a.html</id>
    <published>2020-10-25T08:52:52.000Z</published>
    <updated>2020-12-26T13:52:06.956Z</updated>
    
    <content type="html"><![CDATA[<p><code>Fiddler</code> 是一款比较常用的网络抓包工具，本文记录下使用其完成对模拟器中请求进行抓包的过程。</p><p><a href="https://www.telerik.com/download/fiddler">点击链接</a> 官网下载 Fiddler，可能需要翻墙。下载完毕后，常规安装并登录后打开应用。</p><ol><li><p>点击右上角⚙图标，进入设置页面</p></li><li><p>选择 <code>HTTPS</code> 选项卡，点击 <code>Trust root certficarte</code> ，获取 root 权限。获取完毕后，勾选下方复选框，以支持对 HTTPS 协议的请求。</p></li><li><p>展开 <code>Advanced Settings</code>，将 <code>.crt</code> 证书导出至桌面，后续需要在模拟器中安装。</p></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202010/20201025165959.png" alt="" /></p><ol start="4"><li>选择 <code>Connections</code> 选项卡，可以指定监听端口，直接使用默认的 <code>8866</code> 即可。</li><li>勾选下方 <code>Allow remote computers to connect</code>，我们的模拟器才能连接上来。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202010/20201025170340.png" alt="" /></p><p>至此完成 Fiddler 侧设置，下面安装模拟器。随便选择一家模拟器即可，我这里使用夜神模拟器进行演示。</p><ol><li>确认模拟器开启了 <code>root</code>，我这里默认就已经是开启状态了。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202010/20201025170851.png" alt="" /></p><ol start="2"><li>进入系统 <code>WLAN</code> 设置中，鼠标左键长按已连接的 wifi，在弹出菜单中选择 <code>修改网络</code>。</li><li>展开 <code>高级选项</code>，将 <code>代理</code> 设置为手动，在下方填入代理服务器的IP和端口号。<ul><li>IP 为运行模拟器的宿主机 IP（使用 <code>ipconfig</code> 或 <code>ifconfig</code> 命令查看）</li><li>端口为 Fiddler 的监听端口，即 8866</li></ul></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202010/20201025171321.png" alt="" /></p><p>设置完毕后，尝试在模拟器中打开浏览器，如果一直弹出如下弹窗，我们还需要设置下证书。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202010/20201025171731.png" alt="" /></p><ol start="4"><li>基本所有模拟器都支持宿主机与模拟器之间的文件拷贝，我们需要将前文中导出到桌面的 <code>.crt</code> 文件拷贝到模拟器中。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202010/20201025171951.png" alt="" /></p><ol start="5"><li>进入 <code>设置 -&gt; 安全 -&gt; 从 SD 卡安装</code>，选择上一步中拷入的文件，设置好名字后，点击确认即可。（会提示你给模拟器设置一个密码，正常设置即可）</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202010/20201025172228.png" alt="" /></p><ol start="6"><li>如果安装完毕后，进入浏览器还是弹证书有问题的框，一直点“确定”忽略即可。</li></ol><p>至此完成了模拟器侧的配置，在 Fiddler 首页选择 <code>Live Traffic</code> 选项卡，将右侧的滑动按钮点开，即启动了抓包。此时在模拟器中发起网络请求就可以显示出来了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/202010/20201025172727.png" alt="" /></p><p>当完成抓包后，记得将  <code>Live Traffic</code> 选项卡右侧的滑动按钮关闭，否则可能会影响你正常访问浏览器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Fiddler&lt;/code&gt; 是一款比较常用的网络抓包工具，本文记录下使用其完成对模拟器中请求进行抓包的过程。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.telerik.com/download/fiddler&quot;&gt;点击链接&lt;/a&gt; 官网下载 Fid</summary>
      
    
    
    
    <category term="测试" scheme="https://jitwxs.cn/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="抓包" scheme="https://jitwxs.cn/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
</feed>
